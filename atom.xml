<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>reyshawn.C</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Reyshawn/reyshawn.github.io/"/>
  <updated>2019-05-31T12:04:09.194Z</updated>
  <id>https://github.com/Reyshawn/reyshawn.github.io/</id>
  
  <author>
    <name>Reyshawn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阅读摘要 | issues #1</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/05/31/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81-issues-1/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/05/31/阅读摘要-issues-1/</id>
    <published>2019-05-31T11:44:37.000Z</published>
    <updated>2019-05-31T12:04:09.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi"><a href="#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi" class="headerlink" title="Complex life may only exist because of millions of years of groundwork by ancient fungi"></a><a href="https://news.ycombinator.com/item?id=20039980" target="_blank" rel="noopener">Complex life may only exist because of millions of years of groundwork by ancient fungi</a></h3><p>在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。</p><h3 id="Why-specialization-can-be-a-downside-in-our-ever-changing-world"><a href="#Why-specialization-can-be-a-downside-in-our-ever-changing-world" class="headerlink" title="Why specialization can be a downside in our ever-changing world"></a><a href="https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview" target="_blank" rel="noopener">Why specialization can be a downside in our ever-changing world</a></h3><p>作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。</p><a id="more"></a><h3 id="https-t-me-yifenshijie-2973"><a href="#https-t-me-yifenshijie-2973" class="headerlink" title="https://t.me/yifenshijie/2973"></a><a href="https://t.me/yifenshijie/2973" target="_blank" rel="noopener">https://t.me/yifenshijie/2973</a></h3><p><a href="https://twitter.com/Scholars_Stage/status/1099238789363294208" target="_blank" rel="noopener">T. Greer</a> 用一整条 thread 来阐述，为什么旧的 blog 时代是会比现在的 twitter，reddit，tumbler 更好：</p><ul><li>blog 更专注内容，后者只期望于把用户留在自己的平台里；</li><li>blog 会形成更小到 community，后者，更大的平台，同质化的声音，观点；</li><li>blog 是属于个人的，后者属于平台，遵从商业公司利益，社会主流价值观；</li></ul><p>李如一看到这条 thread 后，<a href="https://t.me/s/yifenshijie/2973" target="_blank" rel="noopener">停止更新了他在 telegram 平台的「一分世界」</a>，认为要知行合一。</p><h3 id="霍洛维兹的欺骗"><a href="#霍洛维兹的欺骗" class="headerlink" title="霍洛维兹的欺骗"></a><a href="https://blog.yitianshijie.net/2019/05/05/horowitz-the-deceiver/" target="_blank" rel="noopener">霍洛维兹的欺骗</a></h3><p>Horowitz  1965 年在纽约卡内基音乐厅舞台演出时，在第二乐章结尾处出了些小瑕疵，后来提供给唱片公司的是编辑过的版本，把瑕疵剪掉了。直到 30 年后，才把 unedited 版本放了出来。</p><blockquote><p>Apple Music 上，<a href="https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/205999185?i=206001029" target="_blank" rel="noopener">在这里</a>可以听到音乐会后出版的唱片里的版本（修过的，从七分二秒开始），<a href="https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/328340329?i=328340362" target="_blank" rel="noopener">这里</a>可以听到日后出版的未修版本（即演出现场版本，勋伯格说的严重错误在七分十一秒）。</p></blockquote><p>以及这里给出网易云音乐的链接，方便收听。<a href="https://music.163.com/#/song?id=405318766" target="_blank" rel="noopener">edited</a> &amp; <a href="https://music.163.com/#/song?id=1298480910" target="_blank" rel="noopener">unedited</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi&quot;&gt;&lt;a href=&quot;#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi&quot; class=&quot;headerlink&quot; title=&quot;Complex life may only exist because of millions of years of groundwork by ancient fungi&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=20039980&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Complex life may only exist because of millions of years of groundwork by ancient fungi&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。&lt;/p&gt;
&lt;h3 id=&quot;Why-specialization-can-be-a-downside-in-our-ever-changing-world&quot;&gt;&lt;a href=&quot;#Why-specialization-can-be-a-downside-in-our-ever-changing-world&quot; class=&quot;headerlink&quot; title=&quot;Why specialization can be a downside in our ever-changing world&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why specialization can be a downside in our ever-changing world&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript async and Promise</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/05/18/JavaScript-async-and-Promise/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/05/18/JavaScript-async-and-Promise/</id>
    <published>2019-05-18T11:42:34.993Z</published>
    <updated>2019-05-18T13:47:39.158Z</updated>
    
    <content type="html"><![CDATA[<p>非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。</p><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><p>JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是</p><pre><code class="javascript">$.get(&#39;http://twitter.com&#39;)$.get(&#39;http://youtube.com&#39;)$.get(&#39;http://google.com&#39;)</code></pre><p>在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 <code>setTimeout()</code> 函数时，程序似乎不会出现 blocking。</p><pre><code class="Javascript">console.log(&#39;hi&#39;)setTimeout(() =&gt; console.log(&#39;there&#39;), 0)console.log(&#39;Welcome!&#39;)// output:// hi// Welcome// there</code></pre><p>这里哪怕是设置 delay 为 0s， <code>setTimeout()</code> 里的函数也是在最后才执行，是怎么回事呢？</p><p>在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 <code>setTimeout()</code> 函数就来自这些提供的 API 中。当我们 declare and call  一个  <code>setTimeout()</code> 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  <code>setTimeout()</code>  里定义的 callback 函数会进入到一个叫 <code>task queue</code> 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  <code>setTimeout()</code> 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。</p><a id="more"></a><p><img src="/images/eventLoop.png" alt="Event Loop"></p><h2 id="Promise-的实现"><a href="#Promise-的实现" class="headerlink" title="Promise 的实现"></a>Promise 的实现</h2><p>Promise 和   <code>setTimeout()</code> 的区别是，<code>setTimeout()</code> 是 delay 一个确定的时间，比如 3000ms，5000ms，然后执行 callback 函数。Promise 本身执行 callback 的时间是不确定的，只有 resolve 之后才算执行完毕，因为 resolve 后会改变 state，比如从 pending 改变成 fulfilled，通过 <code>.then()</code> 的方法执行下一个任务。</p><blockquote><p>Timeouts and Promises serve different purposes.</p><p>setTimeout delays the execution of the code block by a specific time duration. Promises are an interface to allow async execution of code.</p><p>A promise allows code to continue executing while you wait for another action to complete. Usually this is a network call. So anything in your <code>then()</code> call will be executed once the network call (or whatever the promise is waiting for) is completed. The time difference between the start of the promise and the resolution of the promise entirely depends on what the promise is executing, and can change with every execution.</p><p>The reason the promise is executing before your timeout is that the promise isn’t actually waiting for anything so it resolved right away.</p></blockquote><p>以下是来自 <a href="https://www.promisejs.org/implementing/" target="_blank" rel="noopener">Implementing</a>，对于 Promise object 的实现：</p><p>最好的方式是将下面的代码粘贴进 editor 里，调试几遍。不太明白的地方打上断点，或是 <code>console.log()</code>。</p><pre><code class="javascript">let PENDING = 0;let FULFILLED = 1;let REJECTED = 2;function Promise(fn) {  // store state which can be PENDING, FULFILLED or REJECTED  let state = PENDING;  // store value or error once FULFILLED or REJECTED  let value = null;  // store sucess &amp; failure handlers attached by calling .then or .done  let handlers = [];  function fulfill(result) {    state = FULFILLED;    value = result;    handlers.forEach(handle);    handlers = null;  }  function reject(error) {    state = REJECTED;    value = error;    handlers.forEach(handle);    handlers = null;  }  function resolve(result) {    try {      let then = getThen(result);      if (then) {        doResolve(then.bind(result), resolve, reject);        return ;      }      fulfill(result)    } catch (e) {      reject(e);    }  }  function handle(handler) {    if (state === PENDING) {      handlers.push(handler);    } else {      if (state === FULFILLED &amp;&amp;        typeof handler.onFulfilled === &#39;function&#39;) {        handler.onFulfilled(value);      }      if (state === REJECTED &amp;&amp;        typeof handler.onRejected === &#39;function&#39;) {        handler.onRejected(value);      }    }  }  this.done = function (onFulfilled, onRejected) {    // ensure we are always asynchronous    setTimeout(function () {      console.log(&#39;instantly implemented ⚠️&#39;)      handle({        onFulfilled: onFulfilled,        onRejected: onRejected      });    }, 0);  }  doResolve(fn, resolve, reject)  this.then = function (onFulfilled, onRejected) {    var self = this;    return new Promise(function (resolve, reject) {      return self.done(function (result) {        if (typeof onFulfilled === &#39;function&#39;) {          try {            return resolve(onFulfilled(result));          } catch (ex) {            return reject(ex);          }        } else {          return resolve(result);        }      }, function (error) {        if (typeof onRejected === &#39;function&#39;) {          try {            return resolve(onRejected(error));          } catch (ex) {            return reject(ex);          }        } else {          return reject(error);        }      });    });  }}function getThen(value) {  var t = typeof value;  if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) {    var then = value.then;    if (typeof then === &#39;function&#39;) {      return then;    }  }  return null;}function doResolve(fn, onFulfilled, onRejected) {  var done = false;  try {    fn(function (value) {      if (done) return      done = true      onFulfilled(value)    }, function (reason) {      if (done) return      done = true      onRejected(reason)    })  } catch (ex) {    if (done) return    done = true    onRejected(ex)  }}var promise1 = new Promise(function(resolve, reject) {  setTimeout(function() {    resolve(&#39;foo&#39;);  }, 3000);});promise1.then(function(value) {  console.log(value)  // expected output: &quot;foo&quot;});console.log(promise1);</code></pre><p><img src="/images/Promise.png" alt="Promise"></p><p>一些帮助理解这段代码的小 tips：</p><ol><li><code>doResolve()</code> ，第一，会直接执行 <code>fn</code> 函数，也就是声明 Promise 时传递的 callback 函数。第二， 保证 <code>resolve</code> 或是 <code>reject</code> function 仅执行一次。</li><li>每次声明 Promise object，都会先执行一次 <code>doResolve()</code> 函数；</li><li><code>.then()</code> 返回一个新的 Promise object，这个 Promise 会执行 <code>doResolve()</code>  函数，从而会直接执行这个新 Promise 的 callback 函数；line 73 - line 93，执行 callback 函数返回的是 <code>self.done()</code> 函数的执行结果；</li><li><code>.done()</code> 方法会 check state 的值，确定是否将 <code>resolve</code> 添加进 <code>handlers</code> 中；</li><li><code>resolve</code> 函数执行完毕后，将 <code>state</code> 从 <code>PENDING</code> 改为了 <code>FULFILLED</code>，同时 <code>handlers.forEach(handle)</code> 依次执行 <code>.then</code> 方法中添加进去的函数。</li><li><code>resolve</code> 和 <code>reject</code> 都会将值赋给 <code>value</code> 变量；</li><li><code>setTimeout(cb, 0)</code> 使用了上述提到的 event loop，此时 <code>cb</code> 会在几乎 0ms 的间隔时间后，进入 task queue。</li></ol><p>参考链接：</p><ul><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;list=LLhaQJ_wSNai6JEl8bBjymqA&amp;index=3&amp;t=0s" target="_blank" rel="noopener">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></li><li><p><a href="https://www.youtube.com/watch?v=PoRJizFvM7s&amp;list=LLhaQJ_wSNai6JEl8bBjymqA&amp;index=2&amp;t=0s" target="_blank" rel="noopener">Async JS Crash Course - Callbacks, Promises, Async Await</a></p></li><li><p><a href="https://www.promisejs.org/implementing/" target="_blank" rel="noopener">Implementing</a></p></li><li><p><a href="https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt" target="_blank" rel="noopener">Basic Javascript promise implementation attempt</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。&lt;/p&gt;
&lt;h2 id=&quot;Event-loop&quot;&gt;&lt;a href=&quot;#Event-loop&quot; class=&quot;headerlink&quot; title=&quot;Event loop&quot;&gt;&lt;/a&gt;Event loop&lt;/h2&gt;&lt;p&gt;JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;$.get(&amp;#39;http://twitter.com&amp;#39;)
$.get(&amp;#39;http://youtube.com&amp;#39;)
$.get(&amp;#39;http://google.com&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 &lt;code&gt;setTimeout()&lt;/code&gt; 函数时，程序似乎不会出现 blocking。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Javascript&quot;&gt;console.log(&amp;#39;hi&amp;#39;)
setTimeout(() =&amp;gt; console.log(&amp;#39;there&amp;#39;), 0)
console.log(&amp;#39;Welcome!&amp;#39;)

// output:
// hi
// Welcome
// there
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里哪怕是设置 delay 为 0s， &lt;code&gt;setTimeout()&lt;/code&gt; 里的函数也是在最后才执行，是怎么回事呢？&lt;/p&gt;
&lt;p&gt;在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 &lt;code&gt;setTimeout()&lt;/code&gt; 函数就来自这些提供的 API 中。当我们 declare and call  一个  &lt;code&gt;setTimeout()&lt;/code&gt; 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  &lt;code&gt;setTimeout()&lt;/code&gt;  里定义的 callback 函数会进入到一个叫 &lt;code&gt;task queue&lt;/code&gt; 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  &lt;code&gt;setTimeout()&lt;/code&gt; 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>赤烛 - 『还愿』</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/02/21/%E8%B5%A4%E7%83%9B%20-%20%E3%80%8E%E8%BF%98%E6%84%BF%E3%80%8F/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/02/21/赤烛 - 『还愿』/</id>
    <published>2019-02-21T08:24:34.698Z</published>
    <updated>2019-02-23T03:18:14.548Z</updated>
    
    <content type="html"><![CDATA[<p>『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。</p><blockquote><p>奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。</p><p>–<a href="https://hardimage.pro/32" target="_blank" rel="noopener">『奇异的……』 Episode 32 - 硬影像</a></p></blockquote><p>『还愿』同样是具有「奇情片」内核的恐怖游戏。</p><p>以下内容涉及剧透。</p><p>『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。</p><a id="more"></a><blockquote><p>以美麗島雜誌社成員為核心的黨外運動人士，於12月10日組織群眾進行遊行及演講，訴求民主與自由，終結黨禁和戒嚴。</p><p>…</p><p>此事件對台灣往後的政局發展有著重要影響，台灣民眾於美麗島事件後開始關心台灣政治。之後又陸續發生林宅血案（1980）、陳文成命案（1981）、劉江南命案（1984）撼動國際社會，使國民黨政府不斷遭受國際輿論的壓力以及黨外勢力的挑戰，之後國民黨漸漸不再稱呼黨外人士為野心陰謀份子，並逐漸放棄一黨專政的路線以應時勢，乃至於解除持續38年的戒嚴、開放黨禁、報禁。伴隨著國民黨政府的路線轉向，台灣主體意識日益確立，在教育、文化、社會意識等方面都有重大轉變。</p><p>–wikipedia 美麗島事件</p></blockquote><p>「美丽岛军事大审」的同时，1980 年 2 月 28 日，发生了震惊全台湾的「林宅血案」。2017 年上映的电影『血观音』，其中的一些情节就是取材于「林宅血案」，也获得了 54 届金马最佳影片。回到游戏里，1980 年 8 月，在这个时间杜家一家人搬入游戏里的这座「凶宅」。</p><p>最开始看到『还愿』预告的时候，就联想到了电影『血观音』。因为都有着很多相似的元素，比如「凶杀」、「观音」、「巫术」等等。但实际<del>游玩</del>（看过 游戏直播）之后，其实差别还是很大的。『血观音』里有较多的政治意味，『还愿』是在各种恐怖，宗教，民俗包裹下，还是只是在讲一个家庭的奇情故事，格局更小一些。</p><p><img src="/images/Game/devotion.png" alt="devotion"></p><p>1980 年到 1985 年、1986 年这些年，台湾经历了什么？因为 1979 年台湾和美国的断交，和「美丽岛事件」的影响，台湾在政治上逐渐变得民主和开放，经济上同样也是蓬勃发展。民众有了更多的娱乐活动，看电视，虽然当时全台湾只有三个台，大家能看的东西很少，所以港剧『楚留香』引进一下子就能在台湾创下了 70% 的收视率纪录。『五灯奖』是台视制作的一档综艺选秀节目，播出时间长达 33 年，也是游戏里「七彩星舞台」的原型。除了看电视之外，赌博之风也是尤为盛行，比如所谓的「大家乐」，就是 80 年代台湾很流行的一种非法赌博方式。</p><blockquote><p>台湾的娱乐工业 ，在 20 世纪 80 年代开始有了个爆发式的成长 。可以说 ，大家有了钱 ，就开始爱听靡靡之音 。</p><p>电视台三台都有许多的综艺节目出现 ，尤其是星期六及星期天晚上 ，是综艺节目的主战场 。当时的许多主持人或跑龙套的 ，现在都已经是综艺界的大佬 。不过当时的综艺节目 ，在一阵欢乐过后 ，主持人及来宾们一定都会合唱几首 “净化歌曲 ” ——不外就是那些 “观念正确 、意识健康 ” ，鼓吹乐观向上人生观的歌曲 ，就是怕大家听太多靡靡之音导致风气败坏 。于是每当节目结束前 ，我们就会看到所有参与这次节目的艺人排排站 ，在各无线电视台大乐队的伴奏下 ，一起双手打拍子 ，随着伴奏摇摆 ，一起高声齐唱 “净化歌曲 ” 。间奏时 ，主持人还会顺便感谢一下所有来宾 ，以及由 × × ×指挥所领导的 ×视大乐队 。</p><p>–『我们台湾这些年』</p></blockquote><p>也是受赌博风气的影响，出现了「求明牌」。怀着能从赌博里中奖和大捞一笔的心态，很多人希望从一些无关的自然现象，或是求神拜佛来得到神明的暗示。「迷信」在当时成为了很普遍的现象，其实即便是现在的中国农村，逢年过节，丧葬嫁娶，其中的许多繁复的形式和说法，在外人看来，也不过就是迷信罢了。但也要承认，「迷信」是民俗里重要的组成部分，所有的「迷信」也都不是突然出现的，它都和当时的社会背景，政治环境，经济环境，民众心态氛围息息相关。游戏里有很多的台湾 80 年代符号，旧电视机，选秀节目，红龙鱼，观音像，麻将。赤烛在一个封闭空间里，透过这些符号，希望还原出一个 80 年代台湾的真实社会状态。</p><blockquote><p>民眾篤信大家樂中獎號碼會出現於各種超自然現象中，稱為「明牌」。一時間，「求明牌」之風吹遍全臺灣。民眾紛紛湧入大小廟宇、道觀、陰廟、墳墓，向神佛、鬼魂求明牌，甚至膜拜各種物體如樹木、石頭等，希望這些物體上的精怪可以有神示。</p><p>–wikipedia 大家樂 (賭博) </p></blockquote><p>就是在这样一个伴随着动荡，民主，开放的社会氛围下，小杜美心在这新家里度过了他的 5 岁到 11 岁的时光，也就是从 1980 年到 1987 年。</p><p>父亲杜丰于，是一位小有成就的编剧，拿过宝岛文艺奖最佳编剧。母亲巩莉芳本是一位电影明星，在嫁给杜丰于之后，决定息影，在家做全职太太，操持家务。夫妻俩在 1975 年生下杜美心。在此之后，父亲杜丰于的编剧事业却不那么一帆风顺。80 年代的台湾正在逐渐变得开放，因此少有人再去愿意用杜丰于那样传统的，刻板的，了无新意的剧本。剧本多次被拒。事业上的不顺利也让整个家庭的经济情况陷入泥沼。被迫抛售祖宅，也许是因为便宜，搬到了这处据说发生过命案的「凶宅」。乔迁新居，尽管家庭经济状况并不好，喜好面子的父亲仍然邀请众多亲朋好友来家里庆祝。母亲不得不早上四五点起来开始购物置办准备。无论怎样，终于是在新家里安顿下来了。女儿杜美心，父亲母亲最大的希望就是让她像母亲一样成为大明星。从小开始练琴，学唱歌。</p><p>故事是如何慢慢走向悲剧的呢？大概从一开始，从父亲的编剧事业不顺，父亲的好面子，大男子主义，封建迷信开始，故事的结局就已经确定了。毕竟「人是很难改变的」。抛开游戏中所有的恐怖元素， jump scare，恐怖谷理论这些内容。单纯去看这个故事，去看这一家人。除了美心以外的其他人物都太平面扁平了。父亲杜丰于，承担了所有的反面角色的作用，他和何老师成为一切罪行的始作俑者。游戏中有一些父亲与女儿的交互，比如最温馨的故事书那段，拍照片那一段。但是更多的桥段都在展现这个父亲的负面形象，冷漠，易怒，装神弄鬼求神拜佛。父亲的存在，行动，都是在努力地推动整个故事的戏剧冲突，但有时候这样在父亲身上的硬设定，缺乏前因后果的行为，也会缺少说服力。尤其是故事的最后，也就是这故事最大的悲剧，更是觉得这父亲愚笨的难以理喻，怎么就信了别人的胡言乱语呢，你明明还那么爱你自己的女儿。这个地方，有点儿是编剧为了制造这么一个悲剧而一定要让父亲选择这么做。情节的展现也都是何老师的电话，单方面讲述，而父亲杜丰于的内心活动是缺失的。</p><p>母亲巩莉芳，承担了游戏大部分的惊吓点，也是游戏里唯一的女鬼担当。对于母亲的信息，游戏中透漏的很少。我们只知道她是曾经的电影明星，告别影坛后勤俭持家。在 1986 年决定复出，在之后下落不明。故事里可能唯一让人喜欢的，就是小美心了，心理活动刻画的也很多。所有大人的刻画都是平面的，扁平的，就像游戏里出现的纸人一样。</p><p>整体来看，『还愿』仍旧是一步水平上乘的恐怖游戏。尽管借鉴了不少优秀的前作，『寂静岭P.T.』的时空交叉，『艾迪芬奇的记忆』（(What Remains of Edith Finch）的电影叙事。但「赤烛」毕竟是一个台湾团队，『还愿』是一个闽南文化背景的中文作品。当你能无障碍的阅读墙上张贴的小广告，电视广告，背景录音，所获的信息和体验都比你去玩一款欧美文化背景游戏多很多，共鸣也会更大。就好像我去看『牯岭街少年杀人事件』，一定总能带给我最大的震撼一样。</p><p>参考</p><ul><li><a href="https://hardimage.pro/32" target="_blank" rel="noopener">『奇异的……』 Episode 32 - 硬影像</a></li><li>『我们台湾这些年』</li><li><a href="https://www.youtube.com/watch?v=TsCok5DX8uA&amp;frags=pl%2Cwn" target="_blank" rel="noopener">還願Devotion | 玩之前必知的七大民俗文化知識AdamDD</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。&lt;/p&gt;
&lt;p&gt;–&lt;a href=&quot;https://hardimage.pro/32&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;『奇异的……』 Episode 32 - 硬影像&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;『还愿』同样是具有「奇情片」内核的恐怖游戏。&lt;/p&gt;
&lt;p&gt;以下内容涉及剧透。&lt;/p&gt;
&lt;p&gt;『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="故事" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>棋盘上的「古墓丽影」</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/02/07/%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E3%80%8C%E5%8F%A4%E5%A2%93%E4%B8%BD%E5%BD%B1%E3%80%8D/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/02/07/棋盘上的「古墓丽影」/</id>
    <published>2019-02-07T13:15:26.950Z</published>
    <updated>2019-02-07T13:39:29.295Z</updated>
    
    <content type="html"><![CDATA[<p>又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。</p><p><img src="/images/Game/Lara Go 1.jpg" alt="Lara Go 1"></p><p>游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。</p><p>以下内容涉及剧透。</p><a id="more"></a><p><img src="/images/Game/Go-Trilogy.png" alt="Go-Trilogy"></p><p>Lara Go 相比于另外两作，整个游戏特色上加入「冒险」的元素。游戏玩法上引入「攀爬」系统。这样在游戏解密的过程中，就不再只是考虑单纯的 XY 平面移动，还会有来自 Z 轴的变换。这一点体现在，比如堆叠石柱，陷坑，升降机关等等。故事的核心就像最传统，最 typical 的 Tomb Raider 的故事那样，主角 Lara 来到一片丛林，在丛林深处发现一处秘境，那里保存着一个类似「魔方」的器物，获得「魔方」需要三颗石头，获得这三颗石头，必须经历三处迷宫：The Maze of Snakes，The Maze of Stones，The Maze of Spirits。要分别经历这三处迷宫，获得三个石头，打开大门，最后才能获得「魔方」，「魔方」被拿下同时，整个秘境也变得不稳定，似乎开始坍塌陷落，于是就要尽快从秘境中逃脱。这是主线内容，除此以外，Lara Go 里还有两个支线，New Adventure，分别是 The Cave of Fire 和 The Mirror of Spirits。</p><p>最有趣的章节都是来自番外。本作也是这样，全部玩下来，后面的两个 New Adventure，是我认为这个游戏设计的最棒的两个章节。The Cave of Fire 里引入了「复活系统」，在你消灭怪物后的四个回合，怪物会自动复活。所以，不再像之前那样想着如何解决掉怪物。大多数情况需要通过引诱怪物，触发某些机关，或是利用怪物复活前的四个回合，进行一些别的操作。因此，这就让每一步限制得特别死，在若干条线路中，最优的线路可能只有一条，还要不断计算机关复原的回合数，怪物复活的回合数。这些都需要比之前章节更多的思考。The Mirror of Spirits 这个章节实在是太棒了。这个章节里第一次引入了「光」系统，通过「光」来触发机关。另外最具创意的是加入了「镜像」概念。这样的美术风格和玩法模式，相比类似的「纪念碑谷」来讲，都高出太多了。画面里，游戏的一半会出现一个镜像场景，镜像场景里会有一个镜像人物。镜像场景一开始是和真实世界相同，后来就会慢慢出现了些许不同，比如不同的机关，位置不同的出口，不同的怪物，甚至不同的地形布局。这里，镜像人物的死亡，也会导致真实人物的死亡，所以解谜过程中，不仅要注意真实世界的机关，还要兼顾镜像世界里的种种要素。必要的时候，你还要进入到镜像世界，而镜像人物会来到真实世界。这样的设定，把之前那种简单的 turn-based 解谜游戏，可能只是搬动一下开关，到这里直接上升到一个新的 level，无论是游戏玩法，还是美术风格。</p><p><img src="/images/Game/Lara Go .jpg" alt="Lara Go "></p><p><img src="/images/Game/Lara Go 3.jpg" alt="Lara Go 3"></p><p>说下几处自己游玩时印象深刻的点：在获得「魔方」时候，进入下一篇章，The Escape 逃亡章节。场景变的昏暗，黑色剪影的背景是不断掉落的碎石，背景音乐也突然变得紧张急促。在这个章节的游戏解密里，也尽量设计的简单。比如，拉下机关后，需要迅速通过射箭的区域。恰到好处地营造出逃亡的氛围。第二个印象深刻的点，是在火把的第一次出现，拿到火把之后，之前那些吓人的怪物，终于不再敢靠近半步。以及，在  The Mirror of Spirits，镜像的第一次出现，第一次控制真实人物进入到镜像世界里，第一次通过机关，让镜像人物和真实人物出现「异步」行动。这些一切，心中不免会涌现冒险紧张激动和解谜成功的快感，也让我不断地赞叹设计师，赞叹这个游戏的开发者。</p><p><img src="/images/Game/Lara Go 2.jpg" alt="Lara Go 2"></p><p>这部游戏发布于 2015 年，也获得了诸如 Apple Design Award，TGA Best Mobile Game 等多项大奖。但比较可惜的是， Square Enix Montreal 确定不会再制作 Go 系列游戏。</p><blockquote><p>Square Enix Montreal studio head Patrick Naud confirmed that the studio is not working on any new <em>Go</em> games, saying that “one of the challenges we have today is the premium mobile market is diminishing.” He pointed specifically to their prices (the <em>Go</em> games are each $4.99), saying that it’s “such a big barrier for mobile users.”</p></blockquote><p>在移动端平台，大多数游戏的运营模式都是免费加内购的形式。内购的内容也往往是游戏内的金币什么。而对于类似 Lara Go 这样小而美，精致的独立游戏，在浩荡的移动平台市场，并没有什么竞争力。不管是劣币驱除良币，还是说现代生活节奏加快，人们都是更加偏爱快餐类型的消费，游戏也好，电影也好。虽然很明确 Go 不会有下一部续作，但 Go 这种棋盘风格的解谜游戏，这样的游戏方式，因其独有的风格，一定会得到延续。</p><p>参考：</p><ul><li><a href="https://www.theverge.com/2018/6/3/17422724/square-enix-montreal-no-longer-making-go-games-lara-croft-hitman-deus-ex-free-to-play" target="_blank" rel="noopener">Square Enix Montreal is no longer making Go games - The Verge</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Game/Lara Go 1.jpg&quot; alt=&quot;Lara Go 1&quot;&gt;&lt;/p&gt;
&lt;p&gt;游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。&lt;/p&gt;
&lt;p&gt;以下内容涉及剧透。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="故事" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>「User Authentication with Passport and Koa 」Summary</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/01/31/%E3%80%8CUser%20Authentication%20with%20Passport%20and%20Koa%20%E3%80%8DSummary/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/01/31/「User Authentication with Passport and Koa 」Summary/</id>
    <published>2019-01-31T02:11:15.356Z</published>
    <updated>2019-02-02T14:15:36.141Z</updated>
    
    <content type="html"><![CDATA[<p>上周在阅读 <em>Express.js Blueprints</em> 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 <a href="https://mherman.org/blog/user-authentication-with-passport-and-koa/" target="_blank" rel="noopener">User Authentication with Passport and Koa</a> 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。</p><p>需要通过 brew 安装：</p><ul><li>postgresql</li><li>redis</li></ul><p>使用 npm 全局安装：</p><ul><li>knex</li></ul><a id="more"></a><h2 id="文件结构，逻辑"><a href="#文件结构，逻辑" class="headerlink" title="文件结构，逻辑"></a>文件结构，逻辑</h2><p>文件最后的结构：</p><pre><code class="shell">.├── LICENSE├── README.md├── knexfile.js├── package-lock.json├── package.json├── src│   └── server│       ├── auth.js│       ├── db│       │   ├── connection.js│       │   ├── migrations│       │   │   ├── 20170817152841_movies.js│       │   │   └── 20190127152820_users.js│       │   ├── queries│       │   │   ├── movies.js│       │   │   └── users.js│       │   └── seeds│       │       ├── movies_seed.js│       │       └── users.js│       ├── index.js│       ├── routes│       │   ├── auth.js│       │   ├── index.js│       │   └── movies.js│       └── views│           ├── login.html│           ├── register.html│           └── status.html└── test    ├── routes.auth.test.js    ├── routes.index.test.js    ├── routes.movies.test.js    └── sample.test.js</code></pre><p>有一些文件夹，文件属于自动生成的 boilerplate，比如 <code>package.json</code>，<code>knexfile.js</code>，<code>db</code> 文件夹里的一些内容。项目的结构清晰明朗。<code>test</code> 为测试文件夹。测试文件的标题统一加上 <code>test</code> 标示，并用 dot 分隔。这也提醒自己，文件标题的命名可以不使用 underscore 或 dash 来分隔，也可以用 dot。在 <code>server</code> 文件夹下，<code>db</code> 几乎都是数据库，knex 相关的。另外有路由 <code>routes</code> 文件夹和 <code>views</code> 视图文件夹。</p><h2 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h2><p>在 macOS 上直接使用 Brew 安装即可。由于我个人不习惯开机自动启动数据库，那个需要用到类似 <code>service start</code> 的命令。这里是手动开启的办法：</p><pre><code class="shell">$ pg_ctl -D /usr/local/var/postgres start  </code></pre><p>和 Mysql 一样，把 <code>start</code> 可以换成 <code>stop</code>，<code>restart</code>。</p><p>数据库初始化：</p><pre><code class="shell">$ initdb /usr/local/var/postgres  </code></pre><p>在这篇教程里，需要我事先创建两个数据库，创建数据库用如下命令：</p><pre><code class="shell">$ createdb koa_api    $ createdb koa_api_test</code></pre><p><code>psql</code> + Database，进入 database 的命令行。</p><p><code>\dt</code> 显示所有 tables</p><blockquote><p>Please note the following commands:</p><ul><li><code>\list</code> or <code>\l</code>: list all databases</li><li><code>\dt</code>: list all tables in the current database</li></ul><p>You will never see tables in other databases, these tables aren’t visible. You have to connect to the correct database to see its tables (and other objects).</p><p>To switch databases:</p><pre><code>\connect database_name` or `\c database_name</code></pre><p>See the manual about <a href="http://www.postgresql.org/docs/current/interactive/app-psql.html" target="_blank" rel="noopener">psql</a>.</p><p>– <a href="https://dba.stackexchange.com/questions/1285/how-do-i-list-all-databases-and-tables-using-psql" target="_blank" rel="noopener">How do I list all databases and tables using psql?</a></p></blockquote><p>除此以外，还可以通过 Knex 来创建数据库。理论上，可以通过 Knex 来进行所有的数据库操作。</p><h2 id="knex"><a href="#knex" class="headerlink" title="knex"></a>knex</h2><blockquote><p><strong>Knex.js</strong> is a “batteries included” SQL query builder for <strong>Postgres</strong>, <strong>MSSQL</strong>, <strong>MySQL</strong>, <strong>MariaDB</strong>, <strong>SQLite3</strong>, <strong>Oracle</strong>, and <strong>Amazon Redshift</strong> designed to be flexible, portable, and fun to use. </p><p>– <a href="https://knexjs.org" target="_blank" rel="noopener">Knex.js</a></p></blockquote><p>Knex，可以看作是各种不同数据库下统一封装的一套 API。通过 Knex 来和数据库进行交互。比如创建表，更新，添加数据等等。上文引用里提到了「battery-included」一词，意思是「开箱即用」，即这个 Library 已经包含了它所需要的全部依赖 Dependency。我们装完拿来直接用即可，不需要在进行其他 Library 的安装。</p><p><img src="/images/knex.png" alt="knex"></p><p>因为要频繁在 Terminal 里用到 <code>knex</code> 命令，所以最后事先全局安装 Knex。在这篇教程里，我们在使用 Postgresql 创建完数据库以后，会看到需要我们执行这两条命令：</p><pre><code class="shell">$ knex migrate:latest --env development$ knex seed:run --env development</code></pre><hr><p><em>Tips：</em></p><p><em>如果不想要全局安装 Knex，依然想在 Terminal 运行。在生成的 <code>node_modules</code> 文件夹下会有个隐藏文件夹 <code>.bin</code>，里面包含了全部我们可以直接运行的 package。所以直接：</em></p><pre><code class="shell">$ node_modules/.bin/knex init</code></pre><hr><p><code>init</code> 之后，本地会自动生成一个 <code>knexfile.js</code> 文件。里面大致是些 boilerplates。在这篇教程给的 source code 里，    <code>knexfile.js</code> 已经针对 postgresql 配置完毕。但这里要明白 migration 和 seed 两个操作。</p><blockquote><p>Migrations are a way to make database changes or updates, like creating or dropping tables, as well as updating a table with new columns with constraints via generated scripts. We can build these scripts via the command line using <code>knex</code>command line tool.</p></blockquote><p>例如，通过 knex 创建 table：</p><pre><code class="shell">$ knex migrate:make users</code></pre><p>这里会自动生成一个 <code>users.js</code> 文件，文件名前面还会有 time stamp。存储路径在 <code>./server/db/migration/</code>。所有的文件夹都会自动生成。在新生成的文件，我们需要定义新建的这个 table 各个 field 属性。例如在这篇文章的例子里，新建了 users table，定义属性如下：</p><pre><code class="javascript">exports.up = (knex, Promise) =&gt; {  return knex.schema.createTable(&#39;users&#39;, (table) =&gt; {    table.increments();    table.string(&#39;username&#39;).unique().notNullable();    table.string(&#39;password&#39;).notNullable();  });};exports.down = (knex, Promise) =&gt; {  return knex.schema.dropTable(&#39;users&#39;);};</code></pre><p>通过下面这条命令来应用我们定义的属性：</p><pre><code class="shell">knex migrate:latest --env development</code></pre><blockquote><p>To run the migration, use the command:</p><pre><code>knex migrate:latest</code></pre><p>The default environment is development, which works for us here, but if you need to specify a different environment, such as a test environment, then you can use the <em>env</em> flag in the migration command like:</p><pre><code>knex migrate:latest --env test</code></pre></blockquote><p><code>development</code> 是我们事先在 <code>knexfile.js</code> 里定义好的。可以理解为对于 database 的映射。从上面定义的属性中，可以很轻松的知道这个 table 有两个 field，分别是 <code>username</code> 和 <code>password</code>。以及每个 field 的属性都通过 chain function 的形式来表达。</p><blockquote><p>Similar to migrations, the <code>knex</code> module allows us to create scripts to insert initial data into our tables called seed files! If we have relations on our tables, the seeding <strong>must be in a specific order</strong> to so that we can rely on data that might already be in the database. </p></blockquote><p>seed 是用来初始化数据的。同 migrate 一样：</p><pre><code class="shell">$ knex seed:make users$ knex seed:run --env development</code></pre><p>line 1 会自动创建一个 <code>user.js</code> 在路径 <code>./server/db/seeds/</code> 里。line 2 运行这个 seeds，对 table 里数据进行初始化。</p><h2 id="Mocha-js-Chai-js"><a href="#Mocha-js-Chai-js" class="headerlink" title="Mocha.js ,  Chai.js"></a>Mocha.js ,  Chai.js</h2><p>一个测试 module 被称为 specification，简称 spec，结构如下图所示：</p><p><img src="/images/Mocha_test.png" alt="Mocha_test"></p><p>在这篇教程中，用到 Mocha 和 Chai 两个测试 Library。</p><blockquote><ul><li><a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a> – the core framework: it provides common testing functions including <code>describe</code> and <code>it</code> and the main function that runs tests.</li><li><a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a> – the library with many assertions. It allows to use a lot of different assertions, for now we need only <code>assert.equal</code>.</li></ul></blockquote><p>使用 Mocha 进行测试，运行 Mocha，它会自动找项目目录里 test 文件夹下的文件运行。</p><blockquote><p>Mocha automatically looks for tests inside the <code>**test**</code> directory of your project. Hence, you should go ahead and create this directory in your project root.</p></blockquote><p>以下是写的一个很简单的小例子：</p><pre><code class="javascript">const assert = require(&#39;assert&#39;);describe(&quot;sample&quot;, ()=&gt;{    it(&quot;it&#39;s just a test&quot;, ()=&gt;{        let x = 5;        let result = x;        assert.equal(Math.pow(x, 1), result);    });});</code></pre><p>在 Terminal 里运行：</p><pre><code class="shell">$ node_modules/.bin/_mocha  sample    ✓ it&#39;s just a test  1 passing (6ms)</code></pre><p>Chai 的作用是提供了更多测试的方法。例如教程里测试是否 render view 成功：</p><pre><code class="javascript">describe(&#39;GET /auth/register&#39;, () =&gt; {  it(&#39;should render the register view&#39;, (done) =&gt; {    chai.request(server)    .get(&#39;/auth/register&#39;)    .end((err, res) =&gt; {      should.not.exist(err);      res.redirects.length.should.eql(0);      res.status.should.eql(200);      res.type.should.eql(&#39;text/html&#39;);      res.text.should.contain(&#39;&lt;h1&gt;Register&lt;/h1&gt;&#39;);      res.text.should.contain(        &#39;&lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt;&lt;/p&gt;&#39;);      done();    });  });});</code></pre><p>其主要内容检测返回的 res 里有没有想的 DOM Node 。当然，前提还是去验证返回代码是否是 200， 返回文本类型这些。</p><h2 id="Redis-Session"><a href="#Redis-Session" class="headerlink" title="Redis, Session"></a>Redis, Session</h2><p>这篇教程的最后介绍了 redis，把用户的 user 信息从 memory 中拿出来存进 redis 里。这样当关闭浏览器，短时间再重新打开时，不需要重新输入用户名密码进行登录。</p><blockquote><p>It’s a good idea to move session data out of memory and into an external session store as you begin scaling your application.</p></blockquote><p>Redis 同样也是数据库 Database，但不同于之前接触的 MySql，Postgresql，Redis 属于 in-memory database。看了 Wikipedia 的解释。in-memory database 主要依赖于内存 memory，而不是通常的外存 storage。</p><p>关于 session 和 cookie 的区别。</p><p>cookie 是存储在 client 端的，通常是一些偏好设定，比如颜色啊等等，通常不会有敏感信息。session 存储在 server 端，因为 http 通信是无状态的。session 用来保存 client 和 server 之间的通信状态，以及 client 可能会访问多个不同的页面，这些页面都在这一个 server 上，通信的双方并没有变化，通过 session 在不同的页面共享数据。</p><blockquote><p>A session is a unit of maybe variables, state, settings while a certain user is accessing a server/domain in a specific time frame. All the session information is in the traditional model stored on the server (!)</p><p>Because many concurrent users can visit a server/domain at the same time the server needs to be able to distinguish many different concurrent sessions and always assign the right session to the right user. (And no user may “steal” another uses’s session)</p></blockquote><p>这里首先用到两个 middleware，koa-session 和 koa-redis。koa-session 是 koa 基础的 session 管理 middleware。通常 session 是存储在 memory 里的，通过 koa-redis 将 session 存储在 redis 里。</p><p>把 session 存储在 redis 的优势：</p><blockquote><p>Redis is perfect for storing sessions. All operations are performed in memory, and so reads and writes will be fast. </p><p>The second aspect is persistence of session state. Redis gives you a lot of flexibility in how you want to persist session state to your hard-disk. You can go through <a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">http://redis.io/topics/persistence</a> to learn more, but at a high level, here are your options …</p></blockquote><p>依旧是通过 brew 安装 redis。</p><p>redis 启动：</p><pre><code class="shell">$ redis-server /usr/local/etc/redis.conf</code></pre><p>redis 关闭，直接 <code>ctrl</code> + <code>C</code> 或是：</p><pre><code class="shell">$ redis-cli shutdown</code></pre><p>参考：</p><ul><li><a href="https://knexjs.org" target="_blank" rel="noopener">Knex.js</a></li><li><a href="https://medium.com/@jaeger.rob/seed-knex-postgresql-database-with-json-data-3677c6e7c9bc" target="_blank" rel="noopener">Seed Knex PostgreSQL Database with JSON Data</a></li><li><a href="https://github.com/l4nk332/stuff/tree/master/node/Knex">l4nk332/stuff - Github</a></li><li><a href="https://www.zhihu.com/question/24710451" target="_blank" rel="noopener">「batteries-included」该怎么翻译比较好？ - 知乎</a></li><li><a href="https://gist.github.com/NigelEarle/70db130cc040cc2868555b29a0278261" target="_blank" rel="noopener">Migrations &amp; Seeding</a></li><li><a href="https://javascript.info/testing-mocha" target="_blank" rel="noopener">Automated testing with mocha</a></li><li><a href="https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment" target="_blank" rel="noopener">Run mocha tests in test environment? - StackOverflow</a></li><li><a href="https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d" target="_blank" rel="noopener">A quick and complete guide to Mocha testing</a></li><li><a href="https://stackoverflow.com/questions/623815/what-is-the-difference-between-a-session-and-a-cookie" target="_blank" rel="noopener">What is the difference between a Session and a Cookie? - StackOverflow</a></li><li><a href="https://stackoverflow.com/questions/10278683/how-safe-is-it-to-store-sessions-with-redis" target="_blank" rel="noopener">How safe is it to store sessions with Redis?</a></li><li><a href="https://medium.com/@petehouston/install-and-config-redis-on-mac-os-x-via-homebrew-eb8df9a4f298" target="_blank" rel="noopener">Install and config Redis on Mac OS X via Homebrew</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周在阅读 &lt;em&gt;Express.js Blueprints&lt;/em&gt; 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 &lt;a href=&quot;https://mherman.org/blog/user-authentication-with-passport-and-koa/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;User Authentication with Passport and Koa&lt;/a&gt; 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。&lt;/p&gt;
&lt;p&gt;需要通过 brew 安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;postgresql&lt;/li&gt;
&lt;li&gt;redis&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 npm 全局安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;knex&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Front-end/"/>
    
      <category term="Node.js" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>初见 Koa.js</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/01/26/%E5%88%9D%E8%A7%81%20Koa/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/01/26/初见 Koa/</id>
    <published>2019-01-26T11:41:00.000Z</published>
    <updated>2019-01-26T11:48:30.956Z</updated>
    
    <content type="html"><![CDATA[<p>去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：</p><ul><li>Node.js 的异步特性及异步是如何实现的</li><li>异步实现的几种方式，callback 到 Promise 到 async/await</li><li>什么是 middleware？</li><li>ejs template engine</li></ul><p>通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。</p><a id="more"></a><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><code>app.use()</code> 就是添加一个 middleware。我们通过 Koa 进行的许多操作，比如处理 request，处理 data，routing 都是通过 <code>app.use()</code> 来实现的。</p><p><code>ctx</code> 内封装了 request 和 response  object。</p><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use(async function(ctx) {    ctx.body = &quot;hello world ssss&quot;;})app.listen(3000, function() {    console.log(&#39;listen port: 3000...&#39;)})</code></pre><h2 id="渲染-ejs-模版"><a href="#渲染-ejs-模版" class="headerlink" title="渲染 ejs 模版"></a>渲染 ejs 模版</h2><p>这里以 ejs 为例来进行说明，其他的 template engine，使用方法都是相通的。</p><p>使用 npm 安装：</p><pre><code class="shell">$ npm install koa-views --save$ npm install ejs --save</code></pre><p>server.js 内容是</p><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();const views = require(&#39;koa-views&#39;);app.use(views(__dirname + &#39;/views&#39;, {    map: {        html: &#39;ejs&#39;    }}));app.use(async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;);})app.listen(3000, function() {    console.log(&#39;listen port: 3000...&#39;)})</code></pre><p><code>./views/layout.ejs</code> 内容是</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello Koa, This is from ejs&lt;/h1&gt;&lt;/body&gt;</code></pre><p>上面这个例子是不包含传值的，当需要向 template 传递值时，通过 <code>ctx.state</code> 来设置，将上面 render 部分修改成：</p><pre><code class="javascript">app.use(async function(ctx) {    ctx.state = {        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    };    await ctx.render(&#39;layout.ejs&#39;);})</code></pre><p>或者写成 <code>render</code> 的参数，二者是等价的：</p><pre><code class="javascript">app.use(async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;, {        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    });})</code></pre><p>此时 template 修改成：</p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><p>通常我们在写一个 template 的时候，会分成好多组件，首先有一个大体的框架，layout.ejs，新建一个 partials 文件夹，里面存储我们所需的各个组件，如 head.ejs，header.ejs，footer.ejs 等等。我们在一个需要渲染的页面里引用这些组件，那么这个过程在 koa 应该如何实现呢？</p><p>这里直接在 ejs 里使用 <code>include</code> 进行引用。</p><p>header.ejs</p><pre><code class="html">&lt;header&gt;    &lt;p&gt;This is a header&lt;/p&gt;&lt;/header&gt;</code></pre><p>layout.ejs</p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;%- include ./header %&gt;    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><h2 id="Router-路由功能"><a href="#Router-路由功能" class="headerlink" title="Router 路由功能"></a>Router 路由功能</h2><p>对于一个 web site，需要处理各种各样不同的请求，针对不同的请求 request，有着不同的反馈 response，以及可能要调用不同的资源 resource。有些需要调用一些 javascript 文件，css 文件，有些需要调用一些图片 images，有些需要访问数据库。这些不同的资源 resource 有着不同的存储路径，为了让 request 得到合适的反馈，就需要一个 router 路由功能，告诉 server，这个 request，需要去哪里找相应的 resource 去反馈。</p><p><img src="/images/koa_routing.png" alt="koa_routing"></p><pre><code class="shell">$ npm install koa-router --save</code></pre><p>server.js 中修改为：</p><pre><code class="javascript">const Router = require(&#39;koa-router&#39;);const router = new Router()router.get(&#39;/&#39;, async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;, {        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    });})app.use(router.routes());</code></pre><p>我们看到，各个页面的渲染完全由 router 进行了接管。</p><p>上面是最简单的 “Get” 请求，下面是给出一个”Post” 请求的例子，来自 <a href="https://chenshenhai.github.io/koa2-note/note/request/post.html" target="_blank" rel="noopener">koa2 进阶学习笔记</a>，我做了一些小改动，原文使用的是原生 koa 中的 ctx 来判断请求。我这里直接使用了 <code>koa-router</code> 实现，通过对比，也可以明白 koa-router 这个 module 是如何工作的，只不过是在原生 Koa 基础上增加了一层判断。</p><pre><code class="javascript">// receive the posting datafunction parsePostData(ctx) {    return new Promise((resolve, reject) =&gt; {        try {            let postData = &quot;&quot;;            ctx.req.addListener(&#39;data&#39;, (data) =&gt; {                postData += data;            });            ctx.req.addListener(&#39;end&#39;, () =&gt; {                let parseData = parseQueryStr(postData);                resolve(parseData);            });        } catch(err) {            reject(err);        }    })}// convert the posting data to Objectfunction parseQueryStr(data) {    let queryData = {};    let queryStrList = data.split(&#39;&amp;&#39;);    for (let queryStr of queryStrList) {        let itemList = queryStr.split(&#39;=&#39;);        queryData[ itemList[0] ] = decodeURIComponent(itemList[1]);    }    return queryData;}app.use(views(__dirname + &#39;/views&#39;, {    map: {        html: &#39;ejs&#39;    }}));router.get(&#39;/&#39;, async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;, {        data: &#39;no data posted&#39;    });})router.post(&#39;/&#39;, async function(ctx) {    let postData = await parsePostData(ctx);    await ctx.render(&#39;layout.ejs&#39;, {        data: JSON.stringify(postData)    })})app.use(router.routes());</code></pre><p>layout.ejs 添加一个可以提交的表格，注意表格的 <code>method</code> 是 <code>POST</code>，<code>action</code> 是根目录页面 <code>&quot;/&quot;</code>。 </p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;%- include ./header %&gt;    &lt;h1&gt;koa2 request post demo&lt;/h1&gt;      &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;            &lt;p&gt;userName&lt;/p&gt;            &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;            &lt;p&gt;nickName&lt;/p&gt;            &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;            &lt;p&gt;email&lt;/p&gt;            &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;      &lt;/form&gt;      &lt;p&gt;&lt;%- data %&gt;&lt;p&gt;&lt;/body&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 的异步特性及异步是如何实现的&lt;/li&gt;
&lt;li&gt;异步实现的几种方式，callback 到 Promise 到 async/await&lt;/li&gt;
&lt;li&gt;什么是 middleware？&lt;/li&gt;
&lt;li&gt;ejs template engine&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Front-end/"/>
    
      <category term="Node.js" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>异步 &amp; callback</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/01/25/%E5%BC%82%E6%AD%A5%20&amp;%20callback/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/01/25/异步 &amp; callback/</id>
    <published>2019-01-25T03:27:39.896Z</published>
    <updated>2019-01-25T08:52:18.896Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习 Node.js。主要看两本书：<em>Node.js in Practice</em> 和 <em>Node.js Design Patterns</em>。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;solution 实现的。后者就是 <a href="https://search.packtpub.com/" target="_blank" rel="noopener">Packt Publishing</a> 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。</p><p>这篇文章以 <em>Node.js Design Patterns</em> 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。</p><a id="more"></a><h2 id="callback，递归，libuv"><a href="#callback，递归，libuv" class="headerlink" title="callback，递归，libuv"></a>callback，递归，libuv</h2><blockquote><p>Callbacks are to be used when we don’t know <strong>when</strong> something will be done. Again, think of something like an API call, fetching data from a database or I/O with the hard drive.</p><p>–<a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca" target="_blank" rel="noopener">Callbacks in Node.js: Why, When, How?</a></p></blockquote><p>在解决一些算法题目时，经常会用到「递归」。「递归」是函数不断调用自身的过程。callback 和「递归」有些相似，区别是，「递归」是重复的调用自身，而 callback 是去调用另一个不同的函数。本质来讲，都会形成一个  <a href="http://www.wikiwand.com/en/Call_stack" target="_blank" rel="noopener">Call stack</a>。那么为什么可以通过 callback 来实现异步？</p><pre><code class="javascript">// This is synchronous.function processData() {       let data = fetchData();       data += 1;       return data; }// This is asynchronous... function processData(callback) {       fetchData(function (err, data) {             if (err) {           return callback(err);        }             data += 1;             callback(null, data);       }); }</code></pre><p>在  synchronous 中，line 3 获得数据，存储在 data 中，line 4 对数据进行处理。这是一个线性的，单线程的，需要等待的 synchronous 操作。在 async 中，函数 <code>fetchData()</code> 多了一个 callback 参数，后续的数据处理，<code>data += 1</code> 写在了这个 callback 里。也就意味着，当调用 <code>fetchData()</code> 后，整个程序不会停下来等待，而是接着进行下面的操作。当 <code>fetchData()</code> 中获得了数据，更抽象点，是达成了某个条件，则调用 callback 函数。</p><blockquote><p>Callbacks are functions. You pass them to other functions so they can be executed when the time is right, i.e. when the event needed by the callback has happened.</p><p>–<a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca" target="_blank" rel="noopener">Callbacks in Node.js: Why, When, How?</a></p></blockquote><p>看似在 async 中出现了第二条线程，实际上，在 Node.js 中依旧是单线程。通过单线程，来模拟多线程下的 concurrency，借助底层库 <code>libuv</code> 来实现。<code>libuv</code> 让 Node.js 有了 non-blocking I/O 特性。</p><blockquote><p>For example, in Unix, regular filesystem files do not support non-blocking operations, so, in order to simulate a non-blocking behavior, it is necessary to use a separate thread outside the Event Loop. All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the Event Demultiplexer. This is exactly why the Node.js core team created a C library called libuv, with the objective to make Node.js compatible with all the major platforms and normalize the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.</p><p>– p17 <em>Node.js Design Patterns</em></p></blockquote><blockquote><p>This may sound strange if we consider that Node.js is single threaded, but if we remember what we discussed in Chapter 1, Node.js Design Fundamentals, we realize that even though we have just one thread, we can still achieve concurrency, thanks to the nonblocking nature of Node.js.</p><p>–p71 <em>Node.js Design Patterns</em></p></blockquote><blockquote><p>每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 </p><p>–<a href="https://zhuanlan.zhihu.com/p/50480439" target="_blank" rel="noopener">libuv — 知乎专栏</a></p></blockquote><p>这里单线程模拟多线程的原理，和计算机中实现的 concurrency 差不多。因为在计算机中，如果从单个时钟来看，计算机只能完成一条命令。而借助诸如 time shared 分时系统等等，在一段时间内可以认为计算机同时「并发」地在进行多个任务。因此，在 Node.js 由于有了 <code>libuv</code>，会让有着 callback 的函数会进行「异步」操作。</p><blockquote><p>So why show you this? Because you can’t just call one function after another and hope they execute in the right order. Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.</p><p>–<a href="https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced" target="_blank" rel="noopener">JavaScript: What the heck is a Callback?</a></p></blockquote><p>关于 callback 的使用，是有一些 conventions 的。比如 callback 的第一个参数是 error。callback 本身作为函数参数，通常放在最后一个。</p><blockquote><p>Nearly everything in node.js is asynchronous. So, nearly every method that is called, you must specify a callback method to handle the result of the method call. Normally, the callback function takes two parameters: error, result. So it is up to you to check for the error and then handle the result. </p><p>– <a href="https://stackoverflow.com/questions/13789095/understanding-node-js-callback-structure" target="_blank" rel="noopener">understanding node.js callback structure</a></p></blockquote><h2 id="Web-Spider-的-callback-实现"><a href="#Web-Spider-的-callback-实现" class="headerlink" title="Web Spider 的 callback 实现"></a>Web Spider 的 callback 实现</h2><p>在 <em>Node.js Design Patterns</em> 这本书的第二章节，作者通过 web spider 这个例子，介绍了 async 在 node 里的各种实现方案。有最原生的 callback hell，改良后的 callback，也有 async，Promise，generator 等等更加简单的写法。无论使用哪种方式，会用到 <code>fs.stat(path, callback)</code> 和 <code>request(url, callback)</code>[^1]。前者是 Node.js 自身的关于文件操作的一系列 api，后者是一个第三方 module。因为这两个函数都用到了 callback，所以在 debug 模式下，就去更深一层看看是如何运作的。Web Spider 的函数源码已附在了参考链接里。</p><pre><code class="javascript">function download(url, filename, callback) {  console.log(`Downloading ${url}`);  request(url, (err, response, body) =&gt; {    if(err) {      return callback(err);    }    saveFile(filename, body, err =&gt; {      if(err) {        return callback(err);      }      console.log(`Downloaded and saved: ${url}`);      callback(null, body);    });  });}function spider(url, callback) {  const filename = utilities.urlToFilename(url);  fs.stat(filename, err =&gt; {    if(!err) {      return callback(null, filename, false);    }    download(url, filename, err =&gt; {      if(err) {        return callback(err);      }      callback(null, filename, true);    })  });}</code></pre><h3 id="fs-stat"><a href="#fs-stat" class="headerlink" title="fs.stat()"></a>fs.stat()</h3><p>首先进入 <code>fs.stat()</code> 函数：</p><pre><code class="javascript">function stat(path, options, callback) {  if (typeof options === &#39;function&#39;) {    callback = options;    options = {};  }  callback = makeStatsCallback(callback);  path = toPathIfFileURL(path);  validatePath(path);  const req = new FSReqCallback(options.bigint);  req.oncomplete = callback;  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);}</code></pre><p>line 2 到 line 5 是参数判断和转换。line 6 <code>makeStatsCallback(callback)</code>，调用：</p><pre><code class="Javascript">// Special case of `makeCallback()` that is specific to async `*stat()` calls as// an optimization, since the data passed back to the callback needs to be// transformed anyway.function makeStatsCallback(cb) {  if (typeof cb !== &#39;function&#39;) {    throw new ERR_INVALID_CALLBACK();  }  return (err, stats) =&gt; {    if (err) return cb(err);    cb(err, getStatsFromBinding(stats));  };}</code></pre><p>按照注释说明，是 <code>makeCallback()</code> 的特殊情况，那我们就去看看 <code>makeCallback()</code> 是什么。</p><pre><code class="javascript">// Ensure that callbacks run in the global context. Only use this function// for callbacks that are passed to the binding layer, callbacks that are// invoked from JS already run in the proper scope.function makeCallback(cb) {  if (typeof cb !== &#39;function&#39;) {    throw new ERR_INVALID_CALLBACK();  }  return (...args) =&gt; {    return Reflect.apply(cb, undefined, args);  };}</code></pre><p>这段 code  的关键是 <code>Reflect.apply(cb, undefined, args);</code>。按照 MDN 的叙述，<code>Reflect</code> 是：</p><blockquote><p><strong>Reflect</strong> is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener">proxy handlers</a>. <code>Reflect</code> is not a function object, so it’s not constructible.</p><p>Unlike most global objects, <code>Reflect</code> is not a constructor. You cannot use it with a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code>operator</a> or invoke the <code>Reflect</code> object as a function. All properties and methods of <code>Reflect</code>are static (just like the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="noopener"><code>Math</code></a> object).</p></blockquote><p>Reflect 是一个 global object。那么当调用 <code>Reflect.apply()</code>，就是在 global context 下进行的。为什么需要 global context 呢？首先想什么时候会去调用 callback，往往是 error handling，出错的时候，或者是进行最后一步工作的时候。两种情况，无论是哪一种，程序都要从不管多深的 call stack 出来，回到地面，回到 global context，去 handle error，或是进行所有前提工作结束后的下一步工作。</p><p><code>makeStatsCallback(callback)</code>之后关键的三步是：</p><pre><code class="javascript">const req = new FSReqCallback(options.bigint);req.oncomplete = callback;binding.stat(pathModule.toNamespacedPath(path), </code></pre><p><code>FSReqCallback</code> 和 <code>binding</code> 都是对更底层的 C library 调用。</p><pre><code class="javascript">const binding = process.binding(&#39;fs&#39;);const { FSReqCallback, statValues } = binding;</code></pre><p>从这里开始，就逐渐进入 <code>libuv</code> ，C library 的领域了。在这些 C library 中做了什么事情，以我目前的知识结构就很难理解了。只是大体上，应该是设置异步操作，规定在函数结束后去执行 callback 等等，就如这句 <code>req.oncomplete = callback;</code> 字面含义所写的那样。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>request 是一个简单的 Http client。这是它们的 <a href="https://github.com/request/request">Git repo</a>。web spider 的目标就是要下载目标 url 的内容。在上一小节，我们通过 <code>fs.stat()</code> 来检测文件是否存在。当检测到文件不存在的时候，则对目标 url 进行下载。下载这个动作，展开来讲，首要工作就是创建一个 http clinet，来向 server 发送请求，然后接收来自 server 返回的数据。即 <code>body</code> 内容。这些操作，都是通过 <code>request</code> 这个 module 来实现的。创建的 http client 就可类比浏览器，当它发送 request 请求时，需要按照 TCP/IP 协议，加入 head，设置 tunnel，redirect 等等内容。这些是通过 <code>request.Request(params)</code> 来实现的。</p><pre><code class="javascript">function request (uri, options, callback) {  if (typeof uri === &#39;undefined&#39;) {    throw new Error(&#39;undefined is not a valid uri or options object.&#39;)  }  var params = initParams(uri, options, callback)  if (params.method === &#39;HEAD&#39; &amp;&amp; paramsHaveRequestBody(params)) {    throw new Error(&#39;HTTP HEAD requests MUST NOT include a request body.&#39;)  }  return new request.Request(params)}</code></pre><p>line 6 对参数进行初始化：</p><pre><code class="javascript">// organize params for patch, post, put, head, delfunction initParams (uri, options, callback) {  if (typeof options === &#39;function&#39;) {    callback = options  }  var params = {}  if (typeof options === &#39;object&#39;) {    extend(params, options, {uri: uri})  } else if (typeof uri === &#39;string&#39;) {    extend(params, {uri: uri})  } else {    extend(params, uri)  }  params.callback = callback || params.callback  return params}</code></pre><p><code>request()</code> 函数返回的  <code>request.Request(params)</code>  如下：</p><pre><code class="javascript">function Request (options) {  // if given the method property in options, set property explicitMethod to true  // extend the Request instance with any non-reserved properties  // remove any reserved functions from the options object  // set Request instance to be readable and writable  // call init  var self = this  // start with HAR, then override with additional options  if (options.har) {    self._har = new Har(self)    options = self._har.options(options)  }  stream.Stream.call(self)  var reserved = Object.keys(Request.prototype)  var nonReserved = filterForNonReserved(reserved, options)  extend(self, nonReserved)  options = filterOutReservedFunctions(reserved, options)  self.readable = true  self.writable = true  if (options.method) {    self.explicitMethod = true  }  self._qs = new Querystring(self)  self._auth = new Auth(self)  self._oauth = new OAuth(self)  self._multipart = new Multipart(self)  self._redirect = new Redirect(self)  self._tunnel = new Tunnel(self)  self.init(options)}</code></pre><p>注意一下 line 17，<code>stream.Stream.call(self)</code>，在进入这个函数内部后，来到：</p><pre><code class="javascript">// legacy.jsconst EE = require(&#39;events&#39;);const util = require(&#39;util&#39;);function Stream() {  EE.call(this);}</code></pre><p>因为 EE 是来自 events 导出的 EventEmitter，<code>EE.call(this)</code> 实际上是对 EventEmitter 的初始化。到这里会发现，request 处理 callback 所使用的方式，是和 EventEmitter 相关的。具体的继承关系是：</p><p><code>EventEmitter</code> &lt;- <code>stream.Stream</code> &lt;- <code>Request</code></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章最初是想弄清楚 <code>fs</code> 和 <code>request</code> 是怎么处理 callback 函数，是如何去调用的，一路 debug 下去，终归绕不开 <code>libuv</code> ，计算机底层关于 thread 的内容以及网络方面的 TCP/IP 协议。这两方面都是我的知识弱项，因此也就在合适的地方浅尝辄止了。当然，写这篇文章也让我对于 callback 有了更深的理解之外，同时，我想必要抽时间再去好好读读 CSAPP 和 TCP/IP 那两本书了。</p><p>[^1]: 原文判断文件存在用的是 <code>fs.exists()</code>，但这个函数，在我查阅 Node.js Documentation 时发现已经 deprecated，所以稍微修改了一下。</p><hr><p>参考：</p><ul><li><a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca" target="_blank" rel="noopener">Callbacks in Node.js: Why, When, How?</a></li><li><a href="https://stackoverflow.com/questions/24042861/nodejs-what-does-process-binding-mean" target="_blank" rel="noopener">Nodejs: What does <code>process.binding</code> mean?</a></li><li><a href="https://zhuanlan.zhihu.com/p/40977678" target="_blank" rel="noopener">深入出不来nodejs源码-从fs.stat看node架构</a></li><li><a href="https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code">Node.js_Design Patterns Second Edition Code</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始学习 Node.js。主要看两本书：&lt;em&gt;Node.js in Practice&lt;/em&gt; 和 &lt;em&gt;Node.js Design Patterns&lt;/em&gt;。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;amp;solution 实现的。后者就是 &lt;a href=&quot;https://search.packtpub.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Packt Publishing&lt;/a&gt; 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。&lt;/p&gt;
&lt;p&gt;这篇文章以 &lt;em&gt;Node.js Design Patterns&lt;/em&gt; 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Theme 开发不完全记录</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2019/01/20/Hexo%20Theme%20%E5%BC%80%E5%8F%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2019/01/20/Hexo Theme 开发不完全记录/</id>
    <published>2019-01-20T00:22:36.357Z</published>
    <updated>2019-01-22T14:28:53.628Z</updated>
    
    <content type="html"><![CDATA[<p>决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 <a href="https://github.com/getpelican/pelican">Pelican</a> 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：</p><blockquote><p>两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。</p></blockquote><p>那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。</p><p>目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">Themes | Hexo</a> 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。</p><a id="more"></a><h2 id="template-engine-的比较，swig，ejs-or-pug"><a href="#template-engine-的比较，swig，ejs-or-pug" class="headerlink" title="template engine 的比较，swig，ejs or pug"></a>template engine 的比较，swig，ejs or pug</h2><p>Hexo 本身是基于 Nodejs ，它首先通过模版的 render engine，渲染 markdown 和写好的 template 文件，生成相应的 html 。这些生成的 html 文件存储在 <code>public</code> 文件夹中。再通过 git 将这个文件夹的内容发布到 github 上。整个 Hexo 大体的工作逻辑是这样的。工作的第一步是选择合适的 template engine。</p><p>目前可用的 template engine 有多种选择，在 <a href="https://js.libhunt.com/categories/13-templating-engines" target="_blank" rel="noopener">Awesome JS</a> 上会给出各个 template engine 的比较。我最终选择使用 ejs。因为， ejs 本身学习成本很低。ejs 全称 Embedded JavaScript Template，类似于 jsx，直接就是在 html 里写 js 代码就行了。而 Next 主题是用 swig 写的，不选择 swig 的一个很重要原因是它不再维护了，最后一次 commit 是两年前。pug 也是个备受推崇的选择，它的前身是 jade，jade 的 logo 很漂亮，现在更名为 pug，icon 是一个哈巴狗，个人不是太喜欢。pug 的格式和 html 区别也很大，是类似 python 那种缩进形式，如果选择 pug 是需要一段时间去适应的。</p><p>ejs 常用 pattern：</p><ul><li><code>&lt;% %&gt;</code>: 不输出任何内容，用于嵌套 if 或 for 控制语句；</li><li><code>&lt;%- %&gt;</code>: 输出 raw html 文本；</li><li><code>&lt;%= %&gt;</code>:  输出文本，html 中的 tag 如 <code>&lt;div&gt;</code> 会 escape 成 <code>&amp;lt;div&amp;gt;</code></li></ul><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>这是我目前整个主题的文件结构。</p><pre><code class="shell">.├── _config.yml├── languages├── layout│   ├── _partials│   │   ├── footer.ejs│   │   ├── head.ejs│   │   ├── header.ejs│   │   ├── pagination.ejs│   │   └── sidebar.ejs│   ├── archive.ejs│   ├── category.ejs│   ├── index.ejs│   ├── layout.ejs│   ├── page.ejs│   ├── post.ejs│   └── tag.ejs├── scripts└── source    ├── css    │   ├── highlight.css    │   └── main.css    ├── images    │   ├── footer.png    │   └── logo.png    └── js        ├── highlight.min.js        ├── highlightjs-line-numbers.js        ├── jquery-3.3.1.min.js        └── main.js</code></pre><p><code>layout</code> 里存放的是 <code>ejs</code> 模版文件。<code>source</code> 里分了三个文件夹，分别存放用到的 css，图片和 js 文件。<code>languages</code> 和 <code>scripts</code> 这两个文件夹没有用到。</p><p>在 ejs 里使用 source 中的文件：</p><pre><code class="ejs">&lt;%- js(&#39;js/main.js&#39;) %&gt;&lt;%- css(&#39;css/main.css&#39;) %&gt;&lt;img class=&quot;typology-logo&quot; src=&quot;/images/logo.png&quot; alt=&quot;hagoromo&quot; style=&quot;width: 125px;&quot;&gt;</code></pre><p>因为 source 的里文件会原封不动的 copy 进 <code>public</code> 文件夹一份。所以可以直接以上述的形式进行引用。</p><h2 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h2><p>最简单办法是直接 copy 了一份我个人 blog 文件夹到 Desktop 上。把主题文件夹移到 themes 文件夹中。使用 <code>hexo s</code> 进行本地测试。</p><p>我最开始还想着，因为需要 render  ejs 文件，还去看了 nodejs 和 koa 等等内容。后来发现那样做会走不少弯路。最好的测试环境，就是拿真实的环境去模拟，可能会出现的种种状况。</p><h2 id="traps-不完全统计"><a href="#traps-不完全统计" class="headerlink" title="traps 不完全统计"></a>traps 不完全统计</h2><h3 id="archive-页面构建"><a href="#archive-页面构建" class="headerlink" title="archive 页面构建"></a>archive 页面构建</h3><p>我最开始构建 archive 页面时，没太弄明白如何使用插件 hexo-genrator-archive 。所以当时选择新建了一个 page，再在 page 里引入 <code>partial(archive)</code>。loop 所有 posts 时使用 global variable <code>site.posts</code>。这样写，一个最大的问题是，最后 archive 页面展示的 post 顺序，不是按照时间顺序来显示的。我也试了很多办法，设法对 <code>site.posts</code> 排序，但都一一告北。直到搞清楚了 hexo-genrator-archive plugin 的逻辑。</p><p>实际上，安装了 hexo-generator-archive plugin 后，在 hexo 的配置文件本身就有里：</p><pre><code class="yaml">archive_dir: archives</code></pre><p>这样在执行完 <code>hexo g</code> 时候，会自动在 <code>public</code> 文件夹下生成一个 <code>archives</code> 文件，这个文件夹里的内容是和 template 文件 <code>archive.ejs</code> 文件相关联的。也就是，这个插件已经做了所有的「router」路由工作。所以在 template 想要创建一个 archive 点击链接，只需要即可。</p><pre><code class="ejs">&lt;a href=&quot;/archives&quot;&gt;Archive&lt;/a&gt;</code></pre><p>接下来整个 archive 的页面，就是在  <code>archive.ejs</code>  中进行的。在 archive 页面里，采用变量 <code>page.posts</code>，输出的 posts 刚好是按照时间顺序从近到远排列。</p><h3 id="pagination-分页实现"><a href="#pagination-分页实现" class="headerlink" title="pagination 分页实现"></a>pagination 分页实现</h3><p>使用 pagination 分页功能，需要现在 config 里配置：</p><pre><code class="yaml">per_page: 10pagination_dir: page</code></pre><p>此外，hexo 还很贴心地提供了有关 pagination 分页的相关 API。大体的实现是就变的很简单。</p><pre><code class="ejs">&lt;% if (page.total &gt; 1){ %&gt;&lt;div class=&quot;hagoromo-pagination&quot;&gt;    &lt;nav class=&quot;navigation pagination&quot; role=&quot;navigation&quot;&gt;        &lt;% let prev_text = &quot;&amp;laquo; &quot; + __(&#39;prev&#39;); %&gt;        &lt;% let next_text = __(&#39;next&#39;) + &quot; &amp;raquo;&quot;; %&gt;        &lt;%- paginator({          prev_text: prev_text,          next_text: next_text        }) %&gt;    &lt;/nav&gt;&lt;/div&gt;&lt;% } %&gt;</code></pre><p>如果自己去实现的话，还是很复杂的，要考虑当前第几页，最后一页和第一页。当前页和第一页，最后一页差值等等。使用 hexo 提供的 <code>paginator()</code> 函数，就直接自动生成了整个分页 module。这之后 css 样式，按照生成的 html tag 上给的 class 来写就行了。</p><h3 id="banner-下拉动画"><a href="#banner-下拉动画" class="headerlink" title="banner 下拉动画"></a>banner 下拉动画</h3><p>我希望实现的 banner 下拉动画效果是，在窗口下拉大概 600 pixel 时，也就是 scrollY&gt;600 时，banner 从顶部出现并固定，当 scrollY&lt;600 时，banner 隐去。</p><p>大体思路是给 <code>window</code> bind 一个 scroll 事件，实时 listen 窗口的 scrollY 位置。对于动画的实现，有多种方式，可以用 css，也可以用 js。我这里使用了 jQuery 的 <code>animate()</code> 函数，相比 css，控制起来更加灵活方便。</p><pre><code class="javascript">$(window).on(&#39;scroll&#39;, function() {    let scrollPosition = $(this).scrollTop();    let $header = $(&#39;.hagoromo-header&#39;);            if ($(window).width() &gt; 800) {        if (scrollPosition &lt; 200) {            $header.finish();            $header.css({                &#39;top&#39;: &#39;0&#39;,            });        }        if (scrollPosition &gt; 600 &amp;&amp; !$header.hasClass(&#39;hagoromo-header-sticky&#39;)) {            $header.addClass(&#39;hagoromo-header-sticky&#39;);            $header.css({                &#39;top&#39;: &#39;-70px&#39;,            });            $header.animate({                top: &quot;0&quot;            },160)        }        if (scrollPosition &lt; 550 &amp;&amp; $header.hasClass(&#39;hagoromo-header-sticky&#39;)) {            $header.animate({                top: &quot;-70px&quot;            },160, function() {                $header.removeClass(&#39;hagoromo-header-sticky&#39;);                $header.finish();                $header.css(&#39;top&#39;, &#39;0&#39;);            })        }    } else {        if (scrollPosition &gt; 55) {            $header.addClass(&#39;hagoromo-header-hidden&#39;)        } else {            $header.removeClass(&#39;hagoromo-header-hidden&#39;)        }    }});</code></pre><p>其中出现的问题是，因为只要有 animation，都要涉及时间的问题，涉及时间的问题就可以看作一次 asynchronous 调用，这样相比平时 synchronous 调用，速度的快慢，时间的长短，总会带来额外的问题。我当时遇到的问题时，如果过快的从下到上滑到顶部，会出现循环动画，即 banner 不停的上下抖动。问题的原因也很浅显，就是在上一个动画还没结束时，有触发了新一轮的动画，一不小心进入 infinite loop。最后为了解决它，找到了 <code>finish()</code> ，强制结束之前动画。这样一来整体的效果就好多了。</p><h3 id="coding-highlight-和-line-number-显示"><a href="#coding-highlight-和-line-number-显示" class="headerlink" title="coding highlight 和 line number 显示"></a>coding highlight 和 line number 显示</h3><p>hexo 自带了代码高亮。可能是因为我没有定义相关的 css ，实际渲染后，code block 有行号，但是没有高亮。而且 code block 渲染后的 html 后是 <code>&lt;figure&gt;&lt;table&gt;</code> 这样形式。参考网上意见后，通常的解决方案是采取 <code>highlight.js</code>。使用之前先把 hexo 内置的 highlight 关闭，这样 code block 渲染回到了传统 <code>&lt;pre&gt;&lt;code&gt;</code> 形式。引入 <code>highlight.js</code>  提供的 js，css 文件后，初始化后就能看到高亮的代码。这个要注意：</p><pre><code class="javascript">hljs.initHighlightingOnLoad();</code></pre><p>这个函数是要写在自己 js 文件的 <code>$(document).ready()</code> <strong>外面</strong>。因为函数本身已经包含 onload 了。</p><p> <code>highlight.js</code> 自身是没有 line number 显示的。这里需要另外一个扩展 <a href="https://github.com/wcoder/highlightjs-line-numbers.js/">highlightjs-line-numbers.js</a>, 使用方法同  <code>highlight.js</code> 。初始化的时候同样要写在  <code>$(document).ready()</code> <strong>外面</strong>。</p><h3 id="搜索功能的替代性实现"><a href="#搜索功能的替代性实现" class="headerlink" title="搜索功能的替代性实现"></a>搜索功能的替代性实现</h3><p>搜索，平时不经意就会用到功能，凭我个人却写一个 search engine，工作量时很大的。这里有几种方案。</p><p>第一种是调用 algolia 接口，hexo 本身提供了 hexo-algolia 插件。这样实现后的形式是，点击搜索后，页面会出现一个类似 macOS 中 spotlight 那样的输入弹窗，输入要搜索的内容，便会实时给出结果。</p><p>第二种暂时只是我个人想法。就是借助 Google 的 <a href="https://developers.google.com/custom-search/v1/overview" target="_blank" rel="noopener">Custom Search JSON API</a>。但这个需要新建一个 search page 页面来展示 search 结果。需要 js 通过 ajax 得到返回的 json，实时渲染到 search 页面上。</p><p>第三种，也就是我现在使用的比较简单的办法。记得 <a href="www.v2ex.com">V2EX</a> 也是这么实现的。利用 Google 搜索中的 <code>site:</code> 语句。点击 <code>SEARCH</code> 后是直接打开 Google，展示 Google 的站内搜索结果。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文章主要写了自己开发过程中碰到的几个棘手的难题。另外还有一大部分关于设计的内容没有涉及。包括字体，颜色，layout，z-index，footer，responsive design 等等。虽然大部分的设计使用了 typology 的 css 文件，但弄懂其中的逻辑结构，写出更优雅的 css ，还需要一番努力和功夫。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><h3 id="配置-favicon"><a href="#配置-favicon" class="headerlink" title="配置 favicon"></a>配置 favicon</h3><p>需要将自己准备好 icon 文件，通常是 .ico 格式的文件，存储在 <code>source</code> 文件夹下。在 <code>head.ejs</code> 中加入一条 <code>&lt;link&gt;</code> 来声明 favicon 地址：</p><pre><code class="ejs">&lt;% if (theme.favicon){ %&gt;    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%- theme.favicon %&gt;&quot;&gt;&lt;% } %&gt;</code></pre><p>这里使用 if 结构是为了方便在 <code>config.yaml</code> 中进行配置。</p><p>在 theme 的配置文件 <code>config.yaml</code> 中添加，</p><pre><code class="yaml">favicon: ./favicon.ico</code></pre><p>即可。</p><p>测试的话，local 本地测试是没有看到 icon。但 deploy 之后，把网页加入收藏，在 iOS 端的 Safari 等待片刻就能看到 icon，在桌面端的 Chrome 也可以。但唯独桌面端的 Safari 不显示。在 <code>/Users/reyshawn/Library/Safari/Touch\ Icons\ Cache</code> 这个文件夹下能看到，Safari 需要的 icon 都是 png 格式图片，大小通常是 180*180，参考了以下其他能正常显示 icon 的网站，它们 head 的写法。所以要在 <code>&lt;head&gt;</code> 中加入下面两个 <code>&lt;link&gt;</code>:</p><pre><code class="html">&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;./favicon180x180.png&quot; sizes=&quot;180x180&quot;&gt;</code></pre><p>同时要把 png 的icon 移动到 <code>source</code> 文件夹下。这样在桌面端的 Safari 也能正常显示 favicon 了。不得不讲，苹果对于 icon 分辨率的控制之严苛，也侧面反映对设计，整体 icon 一致性的重视。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/25952907/favicon-ico-vs-link-rel-shortcut-icon" target="_blank" rel="noopener">What is the best practice for creating a favicon on a web site?</a></li><li><a href="https://stackoverflow.com/questions/2997437/what-size-should-apple-touch-icon-png-be-for-ipad-and-iphone" target="_blank" rel="noopener">What size should apple-touch-icon.png be for iPad and iPhone?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 &lt;a href=&quot;https://github.com/getpelican/pelican&quot;&gt;Pelican&lt;/a&gt; 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。&lt;/p&gt;
&lt;p&gt;目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 &lt;a href=&quot;https://hexo.io/themes/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Themes | Hexo&lt;/a&gt; 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>1/n- Cycle | 6kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/07/10/1n-%20Cycle%20%7C%206kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/07/10/1n- Cycle | 6kyu/</id>
    <published>2018-07-10T14:58:13.061Z</published>
    <updated>2019-01-23T01:31:08.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Let be <code>n</code> an integer prime with <code>10</code> e.g. <code>7</code>. </p><p><code>1/7 = 0.142857 142857 142857 ...</code>.</p><p>We see that the decimal part has a cycle: <code>142857</code>. The length of this cycle is <code>6</code>. In the same way:</p><p><code>1/11 = 0.09 09 09 ...</code>. Cycle length is <code>2</code>.</p><p><strong>Task</strong></p><p>Given an integer n (n &gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.</p><p><strong>Exemples:</strong></p><pre><code class="python">cycle(5) = -1cycle(13) = 6 -&gt; 0.076923 076923 0769cycle(21) = 6 -&gt; 0.047619 047619 0476cycle(27) = 3 -&gt; 0.037 037 037 037 0370cycle(33) = 2 -&gt; 0.03 03 03 03 03 03 03 03cycle(37) = 3 -&gt; 0.027 027 027 027 027 0cycle(94) = -1 cycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...</code></pre><p>Note</p><ul><li>Translators are welcome for all languages.</li></ul><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="python">import mathimport fractionsdef cycle(n) :    if n==2 or n==5 :        return -1    t = phi(n)    p = primes(t)    divisor = []    for i in p:        x = i        while t % i == 0:            divisor.append(i)            t //= i        if isprime(t):            divisor.append(t)            break    divisor.sort()    print(divisor)    for i in divisor:        if 10**i % n == 1:            break    return idef phi(n):    &#39;&#39;&#39;compute Euler&#39;s totient function values.&#39;&#39;&#39;    amount = 0    for k in range(1, n + 1):        if math.gcd(n, k) == 1:            amount += 1    return amountdef isprime(n):    &quot;&quot;&quot;Returns True if n is prime.&quot;&quot;&quot;    if n == 2:        return True    if n == 3:        return True    if n % 2 == 0:        return False    if n % 3 == 0:        return False    i = 5    w = 2    while i * i &lt;= n:        if n % i == 0:            return False        i += w        w = 6 - w    return Truedef primes(limit):    D = {}    q = 2    while q &lt;= limit:        if q not in D:            yield q            D[q * q] = [q]        else:            for p in D[q]:                D.setdefault(p + q, []).append(p)            del D[q]        q += 1print(cycle(219199))</code></pre><p>这道题是求 $1/n$ 的循环小数位数的。通过观察其实可以得到如下的性质，假设 $1/n$ 的循环小数位数有 $p$ 位，则有：</p><pre><code class="python">10**p % n == 1</code></pre><p>其实也很好理解，就是 10 扩大 $p$ 倍，小数点向右移动 $p$ 位，整数部分恰好位一个循环数，小数部分则等于 $1/n$ 。</p><p>但是如果按照这个思路来进行求解，写一个循环，对一个稍微大一点的数，如上面的 <code>219199</code>，它的循环位数是 <code>36180</code>。暴力写循环根本就行不通！</p><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p> <a href="https://www.codewars.com/users/lechevalier" target="_blank" rel="noopener">lechevalier</a></p><pre><code class="python">def cycle(n):    if not n % 2 or not n % 5:        return -1    x, mods = 1, set()    while x not in mods:        mods.add(x)        x = 10 * x % n    return len(mods)</code></pre><p>lechevalier 所用的这个方法的思路，正是我上面说的，只是并非暴力循环，而是不断迭代。我的疑问是，为何一定能保证，<code>mods</code> 长度刚好是循环的位数？</p><p>方法类似这里给出的答案：<a href="https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits" target="_blank" rel="noopener">How to Calculate Recurring Digits?</a></p><blockquote><p>You can calculate the decimal representation of <code>a / b</code> using the long-division algorithm you learned at school, as Mark Ransom said. To calculate each successive digit, divide the current dividend (numerator or remainder) by <code>b</code>, and find the next dividend as the remainder multiplied by 10 (“bringing down a 0”). When a remainder is the same as some previous remainder, it means that the digits from then on will repeat as well, so you can note this fact and stop.</p></blockquote><p>明白了。其实整个迭代的过程就是去做一次 long division。long division 就是我们小学学过的那种除法计算。</p><p><img src="/images/long division.png" alt="long division"></p><p>那么为什么这样一种循环就比之前我想的那种暴力破解快呢？答案就在于迭代。每次只用 remainder 乘 10 进行迭代，一个非常小的数，算起来自然比用 $10^{n}$ 直接去除要快得多。 </p><p>参考文章：</p><ul><li><a href="https://math.stackexchange.com/questions/1122203/calculating-eulers-totient-function-values" target="_blank" rel="noopener">Calculating Euler’s totient function values.</a></li><li><a href="https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits" target="_blank" rel="noopener">How to Calculate Recurring Digits?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Let be &lt;code&gt;n&lt;/code&gt; an integer prime with &lt;code&gt;10&lt;/code&gt; e.g. &lt;code&gt;7&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/7 = 0.142857 142857 142857 ...&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We see that the decimal part has a cycle: &lt;code&gt;142857&lt;/code&gt;. The length of this cycle is &lt;code&gt;6&lt;/code&gt;. In the same way:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/11 = 0.09 09 09 ...&lt;/code&gt;. Cycle length is &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given an integer n (n &amp;gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exemples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;cycle(5) = -1
cycle(13) = 6 -&amp;gt; 0.076923 076923 0769
cycle(21) = 6 -&amp;gt; 0.047619 047619 0476
cycle(27) = 3 -&amp;gt; 0.037 037 037 037 0370
cycle(33) = 2 -&amp;gt; 0.03 03 03 03 03 03 03 03
cycle(37) = 3 -&amp;gt; 0.027 027 027 027 027 0
cycle(94) = -1 

cycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Translators are welcome for all languages.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="Python" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Lowest base system | 4kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/06/29/Lowest%20base%20system%20%7C%204kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/06/29/Lowest base system | 4kyu/</id>
    <published>2018-06-29T01:58:30.647Z</published>
    <updated>2019-01-22T15:16:13.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>除法，求余，因子</li><li><code>Number.MAX_SAFE_INTEGER</code></li><li>二分法求方程根</li></ul><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Your task is determine lowest number base system in which the input <code>n</code> (base 10), expressed in this number base system, is all <code>1</code> in its digit. See an example:</p><p>‘7’ in base 2 is ‘111’ - fits! answer is 2</p><p>‘21’ in base 2 is ‘10101’ - contains ‘0’ does not fit ‘21’ in base 3 is ‘210’ - contains ‘0’ and ‘2’ does not fit ‘21’ in base 4 is ‘111’ - contains only ‘1’ it fits! answer is 4</p><p><code>n</code> is always less than <code>Number.MAX_SAFE_INTEGER</code>.</p><p>这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。</p><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="javascript">function getMinBase (number) {    if (number == 3) return 2;    var divisor = number -1    for (let i = 2; i != divisor; i++) {        var k = number - 1;        if (i &gt; 5999) break;        while (!(k % i)) {            divisor = k / i            k = divisor - 1;            if (k == 0) return i;        }    }    var _root = [2,3,4,5]    var k = 11    for (let i=0; i&lt;_root.length; i++){        var possible = parseInt(Math.pow(number, 1/_root[i]))        var k = 10 * k + 1        if (toTenBase(k,possible) == number) return possible    }    return number -1;}function toTenBase (number, base) {    n = number + &#39;&#39;;    n = n.split(&#39;&#39;).map(a =&gt; parseInt(a));    res = 0    for (var i = n.length -1; i &gt; -1; i--) {        res += Math.pow(base,i) * n[i]    }    return res;}</code></pre><p>我的这个方法，似乎有些根据测试的数据，有些取巧。代码分成两部分，第一步是通常意义的查找，<code>i</code> 从 2 开始，依此类加，找到每次减 1 都能被整除的最小 <code>i</code> 值。这里面为了优化用了一些技巧，比如最开始一部其实是要找 <code>number - 1</code> 的所有因子，但注意，因为一个数的所有因子都是对称的。譬如 12 的因子：1，2，3，4，6，12。从 3 开始往后的每一个数，在之前的相除过程中都得到了。比如和 2 相除得到 6，和 3 相除得到 4。</p><p>所以我在代码的第一部分加入了变量 <code>divisor</code>，并把它加入了跳出循环的条件。因为一旦 <code>i</code> 超过了 <code>number - 1</code>  的一半，那么就不可能存在除了 <code>number -1</code> 之外的数，使得以之为 base 能得到 <code>111...</code>。</p><p>但因为每次 <code>i</code> 都是类加 1，经过多次反复实验，<code>i</code> 超过 5000 之后，再计算速度已经很慢了。于是我写了另一个函数 <code>toTenBase()</code> ，给出任意 number 和 base，计算以 10 base 的数。最开始写这个函数，不过是为了去找一些规律。对于测试中出现的那些很大的数，大部分的结果都是 <code>number - 1</code>，然而在特殊测试部分，类似这样的 <code>Test.assertEquals(getMinBase(2500050001), 50000);</code> 数就很难办。</p><p>后来也是借助函数 <code>toTenBase()</code> 才发现，特殊测试中的数字，化成 <code>111…</code> 形式的话，大多都是 <code>111</code>，<code>1111</code> 和 <code>11111</code>，再大的话就没有了。如果我们设 <code>getMinBase()</code> 函数所得值为 $x$，而对应 number 为 $n$，对于 <code>111</code> 的类型，则变成一个二次方程求解：</p><p>$$x^2 +x+1=n$$</p><p>相应的 <code>1111</code> 类型，则是三次方程求解：</p><p>$$x^3+x^2 +x+1=n$$</p><p>对于 <code>11111</code> ，按照上述形式也可写出四次方程来。那么问题就是，针对这样的方程，该如何解呢？那么我们就要意识到，$n$ 此时已经很大了，相应 $x$ 也很大。所以它可以转化成一个球极限的问题，即：</p><p>$\lim\limits_{x \to \infty }x^3+x^2 +x+1=\lim\limits_{n \to \infty }n$<br>$\lim\limits_{x \to \infty }x^3=\lim\limits_{n \to \infty }n$</p><p>因此对于第一个方程，n 直接开方，对于第二个方程，n 直接开三次方。理论终究只是理论，实际检验一下，发现可以，于是就是有代码的第二部分。</p><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p> <a href="https://www.codewars.com/users/Voile" target="_blank" rel="noopener">Voile</a></p><pre><code class="javascript">function getMinBase(n) {  for(let i=Math.ceil(Math.log2(n)); i&gt;1; i--) {    let root=Math.round(findRoot(n,i));    if([...&#39;1&#39;.repeat(i)].reduce((s,_)=&gt;s*root+1,0)===n) return root;  }}function findRoot(n,i) {  var l=1, r=Number.MAX_SAFE_INTEGER;  while((r-l)/l&gt;1e-12) {    let m=(r+l)/2, g=(Math.pow(m,i)-1)/(m-1);    g&lt;n?l=m:r=m;  }  return (r+l)/2;}</code></pre><p><code>Number.MAX_SAFE_INTEGER</code> 是我们可以在 JavaScript 中进行 <strong>准确计算</strong>的最大数字，比之更大的数依然存在，但如果参与计算就会误差很大。</p><blockquote><p>The <strong>Number.MAX_SAFE_INTEGER</strong> constant represents the maximum safe integer in JavaScript (<code>253 - 1</code>).</p><p>The reasoning behind that number is that JavaScript uses <a href="http://www.wikiwand.com/en/Double_precision_floating-point_format" target="_blank" rel="noopener">double-precision floating-point format numbers</a> as specified in <a href="http://www.wikiwand.com/en/IEEE_floating_point" target="_blank" rel="noopener">IEEE 754</a> and can only safely represent numbers between <code>-(253 - 1)</code> and <code>253 - 1</code>.</p></blockquote><p> <code>findRoot(n,i)</code> 正是求我上面所说 $i-1$ 阶的一元方程。</p><pre><code class="javascript">&gt;x = findRoot(1000,4)9.641969245752986&gt;Math.pow(x,3) + Math.pow(x,2) + Math.pow(x,1) + 1999.9999999995179</code></pre><p>关键一步：<code>g=(Math.pow(m,i)-1)/(m-1)</code>，写成数学式是：</p><p>$g = \dfrac{m^i -1}{m-1} = m^{i-1}+m^{i-2} + … + m + 1$</p><p>求解的方程是：</p><p>$f(x) = x^{i-1}+x^{i-2} + … + x + 1 = n$</p><p>注意到 <code>r</code> 和 <code>l</code>，分别为计算的上界和下届。求  <code>r</code> 和 <code>l</code> 平均值，带入减 $n$，比较 0，大小，按结果分别再次带入到 <code>r</code> 和 <code>l</code>  中。标准的二分法求根的迭代过程，bisection method。</p><p>下面看一下函数的主体部分。主要是 for 循环中 <code>i</code> 的初始值：<code>i=Math.ceil(Math.log2(n))</code>。<code>i</code> 可能的 1 的最大位数，已知当 base 为 2 的时候，1 的位数是最多了，所以这里才会求 2 的对数。然后得到 i 值的上界，之后再依次减 1。</p><p><a href="https://www.codewars.com/users/spiderPan" target="_blank" rel="noopener">spiderPan</a></p><pre><code class="javascript">function getMinBase(number) {  for (var b =2; b&lt;= Math.floor(Math.sqrt(number)); b++) {    var num = number;    while (num % b == 1) {      num = Math.floor(num / b);      if (num == 1) {        return b;      }    }  }  return number - 1;}</code></pre><p> <a href="https://www.codewars.com/users/LesRamer" target="_blank" rel="noopener">LesRamer</a>, <a href="https://www.codewars.com/users/yurak" target="_blank" rel="noopener">yurak</a></p><pre><code class="javascript">function getMinBase(x) {  function test(b) {    var z = x;    while(z % b == 1)      z = (z - 1) / b;    return z == 0;  }  for(var n = Math.ceil(Math.log2(x)); n &gt;= 1; --n) {    var b = Math.floor(Math.pow(x,1/n));    if (test(b)) return b;    if (test(b-1)) return b-1;  }  return -1;}</code></pre><p>参考文章：</p><ul><li><a href="https://math.stackexchange.com/questions/900869/prove-xn-1-x-1xn-1xn-2-x1" target="_blank" rel="noopener">Prove $x^n−1=(x−1)(x^{n−1}+x^{n−2}+…+x+1)$</a></li><li><a href="http://www.wikiwand.com/zh/二分法_(數學" target="_blank" rel="noopener">二分法 (數學)</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;除法，求余，因子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二分法求方程根&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Your task is determine lowest number base system in which the input &lt;code&gt;n&lt;/code&gt; (base 10), expressed in this number base system, is all &lt;code&gt;1&lt;/code&gt; in its digit. See an example:&lt;/p&gt;
&lt;p&gt;‘7’ in base 2 is ‘111’ - fits! answer is 2&lt;/p&gt;
&lt;p&gt;‘21’ in base 2 is ‘10101’ - contains ‘0’ does not fit ‘21’ in base 3 is ‘210’ - contains ‘0’ and ‘2’ does not fit ‘21’ in base 4 is ‘111’ - contains only ‘1’ it fits! answer is 4&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; is always less than &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>@wraps | 6kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/06/25/@wraps%20%7C%206kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/06/25/@wraps | 6kyu/</id>
    <published>2018-06-25T02:21:13.613Z</published>
    <updated>2019-01-22T15:14:53.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li><code>decorator</code> 装饰器用法</li><li><code>try</code>…<code>except</code>… <code>else</code> control flow</li><li><code>getattr()</code> 和 <code>setattr()</code></li><li><code>__dict__.update()</code></li></ul><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Implement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here’s an example :</p><pre><code class="python">def identity(func):  @wraps(func)  def wrapper(*args, **kwargs):    &quot;&quot;&quot;Wraps func&quot;&quot;&quot;    return func(*args, **kwargs)  return wrapper@identitydef return_one():  &quot;&quot;&quot;Return one&quot;&quot;&quot;  return 1return_one.__name__ == &#39;return_one&#39; # If wraps hadn&#39;t been used, __name__ would be equal to &#39;wrapper&#39;return_one.__doc__ == &#39;Return one&#39; # If wraps hadn&#39;t been used, __doc__ would be equal to &#39;Wraps func&#39;</code></pre><p><strong>Note: of course, you may not use the functools module for this kata.</strong></p><p>题目要求，经过一次二重的装饰器，保留原来函数的 <code>__name__</code> 和 <code>__doc__</code>。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 <code>__name__</code> 和 <code>__doc__</code>  得到保留，及为原函数的值。</p><p>依照题目给的例子，就是输出是被 decorator wraps 修饰过的 <code>wrapper</code> 函数，即函数主体和功能还是 <code>wrapper</code>，但因为被 <code>wraps</code> 装饰了，输出的 <code>wrapper</code> 函数的  <code>__name__</code> 和 <code>__doc__</code>  值为原函数 <code>return_one</code> 的值。</p><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="python">def wraps(func):    def first(wrapper):        return func    return first</code></pre><p>我的这个方法，其实是不正确的。因为我这个经过几次 decorate 又输出了原函数，按道理应该是输出 <code>wrapper</code> 函数的。</p><h2 id="Other-Solution"><a href="#Other-Solution" class="headerlink" title="Other Solution"></a>Other Solution</h2><p> <a href="https://www.codewars.com/users/siebenschlaefer" target="_blank" rel="noopener">siebenschlaefer</a></p><pre><code class="python">def wraps(wrapped):    def wrapper(func):        for attr in (&#39;__module__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;):            try:                value = getattr(wrapped, attr)            except AttributeError:                pass            else:                setattr(func, attr, value)        func.__dict__.update(getattr(wrapped, attr, {}))        func.__wrapped__ = wrapped        return func    return wrapper</code></pre><p>首先注意一下对应关系。经过一次二重的装饰后，<br><code>wrapped</code> ➡️ <code>return_one</code><br><code>func</code> ➡️ <code>wrapper</code></p><p>目标是输出 <code>func</code> ，但要把 <code>func</code> 的 <code>__name__</code> 和 <code>__doc__</code> 进行修改。修改这些 built-in 的值用到了 <code>getattr()</code> 和 <code>setattr()</code>。</p><blockquote><p>You use them if the attribute you want to access is a variable and not a literal string. They let you parameterize attribute access/setting.</p><p>There’s no reason to do <code>getattr(x, &#39;foobar&#39;)</code>, but you might have a variable called <code>attr</code> that could be set to “foobar” or “otherAttr”, and then do <code>getattr(x, attr)</code>.</p></blockquote><p><code>try</code>…<code>except</code>… <code>else</code>，<code>else</code> 后面是当 <code>try</code> 中的内容无错误时才执行的，否则时执行 <code>except</code> 中的内容。</p><blockquote><p><code>try</code>:<br>   Normal execution block<br><code>except</code> A:<br>   Exception A handle<br><code>except</code> B:<br>   Exception B handle<br><code>except</code>:<br>   Other exception handleelse:<br><code>else</code>:<br>   if no exception,get here<br><code>finally</code>:<br>   print(“finally”)   </p></blockquote><p> <a href="https://www.codewars.com/users/Voile" target="_blank" rel="noopener">Voile</a></p><pre><code class="python">def wraps(func):    def f(g):        g.__name__ = func.__name__        g.__doc__ = func.__doc__        return g    return f</code></pre><p>Voile 的解法更简洁。</p><p>参考文章：</p><ul><li><a href="https://stackoverflow.com/questions/19123707/why-use-setattr-and-getattr-built-ins" target="_blank" rel="noopener">Why use setattr() and getattr() built-ins?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;decorator&lt;/code&gt; 装饰器用法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;try&lt;/code&gt;…&lt;code&gt;except&lt;/code&gt;… &lt;code&gt;else&lt;/code&gt; control flow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getattr()&lt;/code&gt; 和 &lt;code&gt;setattr()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__dict__.update()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Implement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here’s an example :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def identity(func):
  @wraps(func)
  def wrapper(*args, **kwargs):
    &amp;quot;&amp;quot;&amp;quot;Wraps func&amp;quot;&amp;quot;&amp;quot;
    return func(*args, **kwargs)
  return wrapper

@identity
def return_one():
  &amp;quot;&amp;quot;&amp;quot;Return one&amp;quot;&amp;quot;&amp;quot;
  return 1

return_one.__name__ == &amp;#39;return_one&amp;#39; # If wraps hadn&amp;#39;t been used, __name__ would be equal to &amp;#39;wrapper&amp;#39;
return_one.__doc__ == &amp;#39;Return one&amp;#39; # If wraps hadn&amp;#39;t been used, __doc__ would be equal to &amp;#39;Wraps func&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note: of course, you may not use the functools module for this kata.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目要求，经过一次二重的装饰器，保留原来函数的 &lt;code&gt;__name__&lt;/code&gt; 和 &lt;code&gt;__doc__&lt;/code&gt;。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 &lt;code&gt;__name__&lt;/code&gt; 和 &lt;code&gt;__doc__&lt;/code&gt;  得到保留，及为原函数的值。&lt;/p&gt;
&lt;p&gt;依照题目给的例子，就是输出是被 decorator wraps 修饰过的 &lt;code&gt;wrapper&lt;/code&gt; 函数，即函数主体和功能还是 &lt;code&gt;wrapper&lt;/code&gt;，但因为被 &lt;code&gt;wraps&lt;/code&gt; 装饰了，输出的 &lt;code&gt;wrapper&lt;/code&gt; 函数的  &lt;code&gt;__name__&lt;/code&gt; 和 &lt;code&gt;__doc__&lt;/code&gt;  值为原函数 &lt;code&gt;return_one&lt;/code&gt; 的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Trees | 5kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/06/23/Binary%20Search%20Trees%20%7C%205kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/06/23/Binary Search Trees | 5kyu/</id>
    <published>2018-06-23T05:01:32.183Z</published>
    <updated>2019-01-22T15:15:34.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li><code>__str__()</code> 的几种定义方法：如  <code>&quot;%s&quot; % value</code>  和 <code>&#39;{}&#39;.format()</code></li><li>A <code>and</code> B <code>and</code> C</li><li><code>if</code>  … <code>else</code> 单行语句</li><li><code>for</code> … <code>in</code> 单行语句</li><li><code>join()</code> 函数</li><li><code>str()</code> 函数与 <code>__str__()</code> 方法</li></ul><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>A <code>Tree</code> consists of a root, which is of type <code>Node</code>, and possibly a left subtree of type <code>Tree</code> and possibly a right subtree of type <code>Tree</code>. If the left subtree is present, then all its nodes are less than the parent tree’s root and if the right tree is present, then all its nodes are greater than the parent tree’s root. In this kata, classes <code>Tree</code> and <code>Node</code> have been provided. However, the methods <code>__eq__</code>, <code>__ne__</code>, and <code>__str__</code> are missing from the <code>Tree</code> class. Your job is to provide the implementation of these methods. The example test cases should provide enough information to implement these methods correctly.</p><p>As an illustrative example, here is the string representation of a tree that has two nodes, ‘B’ at the root and ‘C’ at the root of the right subtree. The left subtree is missing and the right subtree is a leaf, i.e., has no subtrees: </p><pre><code class="python">&#39;[_ B [C]]&#39;</code></pre><p>This tree is obtained by evaluating the following expression:</p><pre><code class="python">Tree(Node(&#39;B&#39;), None, Tree(Node(&#39;C&#39;))))</code></pre><p>Notice in particular that when one subtree, but not both, is missing, an underscore is in its place, a single space separates the root node from the subtrees, and when both subtrees are missing, the root node is enclosed in brackets.</p><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="python">class Tree(object):    def __init__(self, root, left=None, right=None):        assert root and type(root) == Node        if left: assert type(left) == Tree and left.root &lt; root        if right: assert type(right) == Tree and root &lt; right.root        self.left = left        self.root = root        self.right = right    def is_leaf(self):        return not(self.left or self.right)    def __str__(self):        rep = &#39;[&#39;        if self.left is not None:            rep += self.left.__str__() + &#39; &#39;        elif self.right is not None:            rep += &#39;_ &#39; + self.root.__str__() + &#39; &#39; + self.right.__str__()            return rep + &#39;]&#39;        rep += self.root.__str__()        if self.right is not None:            rep += &#39; &#39; + self.right.__str__()        elif self.left is not None:            rep = self.left.__str__() + &#39; &#39; + self.root.__str__() + &#39; _&#39;            return rep + &#39;]&#39;        return rep + &#39;]&#39;    def __eq__(self, other):        if (self is None) and (other is None):            return True        if self and other and self.root == other.root:            return (self.left == other.left) and (self.right == other.right)        else:            return False    def __ne__(self, other):        return not self == otherclass Node(object):    def __init__(self, value, weight=1):        self.value = value        self.weight = weight    def __str__(self):        return str(self.value)    def __lt__(self, other):        return self.value &lt; other.value    def __gt__(self, other):        return self.value &gt; other.value    def __eq__(self, other):        return self.value == other.value    def __ne__(self, other):        return self.value != other.value</code></pre><h2 id="Other-Solution"><a href="#Other-Solution" class="headerlink" title="Other Solution"></a>Other Solution</h2><p> <a href="https://www.codewars.com/users/siebenschlaefer" target="_blank" rel="noopener">siebenschlaefer</a></p><pre><code class="python">class Tree(object):    # ... 其余重复部分省略    def __str__(self):        if self.is_leaf():            return &quot;[%s]&quot; % self.root        return &quot;[%s %s %s]&quot; % (            self.left if self.left else &quot;_&quot;,            self.root,            self.right if self.right else &quot;_&quot;)    def __eq__(self, other):        if not other:            return False        return (            self.root == other.root and            self.left == other.left and            self.right == other.right)    def __ne__(self, other):        return not (self == other)# ... 其余重复部分省略</code></pre><p>这个在 <code>__str__()</code> 部分写得异常简洁，并且利用到了 <code>is_leaf()</code> 方法。如果  <code>is_leaf()</code> 返回值为 <code>True</code>，则说明 self 没有 left 和 right。还有 <code>if</code> 的单行写法，也要学会使用。</p><p><code>__eq__()</code> 方法的 <code>and</code> 连续使用，要用括号括起来。</p><p><a href="https://www.codewars.com/users/Voile" target="_blank" rel="noopener">Voile</a></p><pre><code class="python">class Tree(object):    def __init__(self, root, left=None, right=None):        assert root and type(root) == Node        if left: assert type(left) == Tree and left.root &lt; root        if right: assert type(right) == Tree and root &lt; right.root        self.left = left        self.root = root        self.right = right    def is_leaf(self):        return not(self.left or self.right)    def __str__(self):        if type(self.left) != Tree and type(self.right) != Tree: return &#39;[{}]&#39;.format(self.root)        if type(self.left) == Tree and type(self.right) == Tree: return &#39;[{} {} {}]&#39;.format(self.left, self.root, self.right)        return &#39;[{}]&#39;.format(&#39; &#39;.join(str(v) if v else &#39;_&#39; for v in [self.left, self.root, self.right]))    def __eq__(self, other):        if self.root != other.root: return False        if type(self.left) != type(other.left): return False        if type(self.right) != type(other.right): return False        return self.left == other.left and self.right == other.right    def __ne__(self, other):        return not self == other</code></pre><p>Voile 在 <code>__str__()</code> 中用的 return 形式是 <code>&#39;[{}]&#39;.format()</code>，也是分了三种情况。注意第三种的单行写法，形如：</p><pre><code class="python">&gt;&gt;&gt; &#39; &#39;.join(str(v) if v else &#39;_&#39; for v in [1, 0, 3])&#39;1 _ 3&#39;&gt;&gt;&gt; &#39;&#39;.join(str(v) if v else &#39;_&#39; for v in [1, 0, 3])&#39;1_3&#39;</code></pre><p><code>__eq__()</code> 写法思路和我的写法差不多，都是在保证 <code>self.root == other.root</code> 的情况下，输出一个 <code>and</code> 并列语句，<code>self.left == other.left and self.right == other.right</code>。当然，他这里用 <code>type</code> 来判断是否是 Node 还是 None。</p><p> <a href="https://www.codewars.com/users/brettso" target="_blank" rel="noopener">brettso</a></p><pre><code class="python">class Tree(object):    def __init__(self, root, left=None, right=None):        assert root and type(root) == Node        if left: assert type(left) == Tree and left.root &lt; root        if right: assert type(right) == Tree and root &lt; right.root        self.left = left        self.root = root        self.right = right    def is_leaf(self):        return not(self.left or self.right)    def __str__(self):        if self.is_leaf():            return &#39;[&#39; + self.root.value + &#39;]&#39;        left = &quot;_&quot; if not self.left else self.left.__str__()        right = &quot;_&quot; if not self.right else self.right.__str__()        return &#39;[&#39; + left + &#39; &#39; + self.root.value + &#39; &#39; + right + &#39;]&#39;        def __eq__(self, other):        return self.__str__() == other.__str__()    def __ne__(self, other):        return self.__str__() != other.__str__()</code></pre><p>这个 <code>__eq__()</code> 的写法很巧妙啊，直接利用了 <code>__str__()</code> 来进行判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__str__()&lt;/code&gt; 的几种定义方法：如  &lt;code&gt;&amp;quot;%s&amp;quot; % value&lt;/code&gt;  和 &lt;code&gt;&amp;#39;{}&amp;#39;.format()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;and&lt;/code&gt; B &lt;code&gt;and&lt;/code&gt; C&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt;  … &lt;code&gt;else&lt;/code&gt; 单行语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt; … &lt;code&gt;in&lt;/code&gt; 单行语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join()&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str()&lt;/code&gt; 函数与 &lt;code&gt;__str__()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;A &lt;code&gt;Tree&lt;/code&gt; consists of a root, which is of type &lt;code&gt;Node&lt;/code&gt;, and possibly a left subtree of type &lt;code&gt;Tree&lt;/code&gt; and possibly a right subtree of type &lt;code&gt;Tree&lt;/code&gt;. If the left subtree is present, then all its nodes are less than the parent tree’s root and if the right tree is present, then all its nodes are greater than the parent tree’s root. In this kata, classes &lt;code&gt;Tree&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; have been provided. However, the methods &lt;code&gt;__eq__&lt;/code&gt;, &lt;code&gt;__ne__&lt;/code&gt;, and &lt;code&gt;__str__&lt;/code&gt; are missing from the &lt;code&gt;Tree&lt;/code&gt; class. Your job is to provide the implementation of these methods. The example test cases should provide enough information to implement these methods correctly.&lt;/p&gt;
&lt;p&gt;As an illustrative example, here is the string representation of a tree that has two nodes, ‘B’ at the root and ‘C’ at the root of the right subtree. The left subtree is missing and the right subtree is a leaf, i.e., has no subtrees: &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&amp;#39;[_ B [C]]&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This tree is obtained by evaluating the following expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;Tree(Node(&amp;#39;B&amp;#39;), None, Tree(Node(&amp;#39;C&amp;#39;))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice in particular that when one subtree, but not both, is missing, an underscore is in its place, a single space separates the root node from the subtrees, and when both subtrees are missing, the root node is enclosed in brackets.&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="Python" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Born to be chained | 4kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/06/20/Born%20to%20be%20chained%20%7C%204kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/06/20/Born to be chained | 4kyu/</id>
    <published>2018-06-20T03:14:56.675Z</published>
    <updated>2019-01-22T15:15:53.626Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于 Object 的遍历；</li></ul><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Function composition is a powerful technique. For example:</p><pre><code class="javascript">function sum(x, y) {  return x + y;}function double(x) {  return sum(x, x);}function minus (x, y) {  return x - y;}function addOne(x) {  return sum(x, 1);}double(sum(2, 3)); // 10</code></pre><p>But in complex expressions, composition may be difficult to understand. For example:</p><pre><code class="javascript">double(double(addOne(sum(7, minus(sum(5, sum(4, 5)), 4))))); // 72</code></pre><p>In this kata, we will implement a function that allows us to perform this by applying a fluid style:</p><pre><code class="javascript">c.sum(4, 5).sum(5).minus(4).sum(7).addOne().double().double().execute(); // 72</code></pre><p>Your job is implement the <code>chain</code> function:</p><pre><code class="javascript">function chain(fns) {}var c = chain({sum: sum, minus: minus, double: double, addOne: addOne});</code></pre><p>As you can see, this function receives the methods to be chained and returns an object that allows you to call the chained methods. The result is obtained by calling the <code>execute</code>method.</p><p>Chained functions receive an arbitrary number of arguments. The first function in the chain receives all its arguments. In the other functions, the first argument is the result of the previous function and then it only receives the remainder arguments (second, third, etc.). The tests always pass the appropriate arguments and you do not have to worry about checking this.</p><p>Note that the chain can be reused (the internal state is not stored):</p><a id="more"></a><pre><code class="javascript">c.sum(3, 4).execute(); //7c.sum(1, 2).execute(); //3</code></pre><p>Other examples:</p><pre><code class="javascript">var c1 = c.sum(1, 2);c1.execute(); // == fns.sum(1, 2) == 3c1.double().execute(); // == fns.double(fns.sum(1, 2)) == 6c1.addOne().execute(); // == fns.addOne(fns.sum(1, 2)) == 4c1.execute(); // == fns.sum(1, 2) == 3var c2 = c1.sum(5);c2.addOne().execute(); // == fns.addOne(fns.sum(fns.sum(1, 2) 5)) == 9c2.sum(3).execute(); // == fns.sum(c1.sum(fns.sum(1, 2), 5), 3) == 11c2.execute(); // == fns.sum(fns.sum(1, 2), 5) == 8c1.execute(); // == fns.sum(1, 2) == 3</code></pre><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p> <a href="https://www.codewars.com/users/ooflorent" target="_blank" rel="noopener">ooflorent</a>, <a href="https://www.codewars.com/users/ChungGor" target="_blank" rel="noopener">ChungGor</a>, <a href="https://www.codewars.com/users/pompeu2004" target="_blank" rel="noopener">pompeu2004</a>, <a href="https://www.codewars.com/users/guilhermeconti" target="_blank" rel="noopener">guilhermeconti</a>, <a href="https://www.codewars.com/users/lwio" target="_blank" rel="noopener">lwio</a> (plus 2 more warriors)</p><pre><code class="javascript">function chain(fns) {  function ChainWrapper(x) {    this._ = x  }  Object.keys(fns).forEach(function(prop) {    var fn = fns[prop]    ChainWrapper.prototype[prop] = function() {      var args = [].slice.call(arguments)      if (this._ != null) args.unshift(this._)      var x = fn.apply(null, args)      return new ChainWrapper(x)    }  })  ChainWrapper.prototype.execute = function() {    return this._  }  return new ChainWrapper()}</code></pre><p>line 6: 关注一下对于一般 Object  的遍历方法。主要用到 <code>Object.keys()</code> 和 <code>forEach()</code>，另外相对应的也有 <code>Object.values()</code>。</p><p>line 9: ChainWrapper 是一个函数，给这个函数添加若干子函数（或也称 method）的办法。这里要弄明白一个问题，直接用 <code>ChainWrapper[prop]</code> 和使用 <code>ChainWrapper.prototype[prop]</code> 的区别在哪里。前者只给该函数加入了一个子函数，而后者透过原型链，给最原始的<strong>函数对象</strong>加入了一个子函数，如果讲函数作为 Object 进行创建，形如 <code>var a = new ChainWrapper(3)</code> 这样，前者创建的子函数不复存在，后者创建的子函数依然存在。如下例子：</p><pre><code class="javascript">function ChainWrapper(x) {    this._ = x}ChainWrapper[&#39;sum&#39;] = (a,b) =&gt; (a+b)ChainWrapper.sum(2,3) //5ChainWrapper[&#39;sum&#39;](2,3) //5var a = new ChainWrapper(1) //ChainWrapper { _: 1 }a.sum(2,3) //TypeError: a.sum is not a functionChainWrapper.prototype[&#39;sum&#39;] = (a,b) =&gt; (a+b)var a = new ChainWrapper(1) //ChainWrapper { _: 1 }a.sum(2,3) //5</code></pre><p>当将函数利用 new 关键字进行创建的时候，得到的是一个 Object 而不是 function。</p><p>line 11: 初次定义时，<code>chain()</code> 函数返回的是 <code>return new ChainWrapper()</code>，此时 Object 内的 <code>this._</code> 为 <code>undefined</code>。当 Object 开始 chain 第一个子函数时，得到的运算结果记录在 <code>this._</code> 中，此时为非 null 值，则在下一次 chain 的时候，前一次函数的运算结果要作为下一次 chain 的参数传入进去，所以要 <code>args.unshift(this._)</code>。</p><p>但这里有一个小 bug，当 <code>this._</code> 出现 <code>NaN</code> 时，此时判定 <code>NaN != null</code>  的结果会是 <code>true</code>。然后会把 <code>NaN</code> 传入到参数的最开头，那么每次结果都会是 <code>NaN</code>。修复的办法就是判定 <code>x</code> 是否为 <code>NaN</code>，在 <code>apply()</code> 方法使用后加一个条件结构。</p><pre><code class="javascript">if (isNaN(x)) return new ChainWrapper();</code></pre><p>但注意，这里默认了当输出为 <code>NaN</code> 为输出无效，不会保留之前的参数。如果要保留参数，但不同函数参数数量都不一样，就比较复杂了。比如 <code>sum()</code> 两个数相加，只输入 1 个数时会得到 <code>NaN</code>，此时输入的那个数也是直接舍弃不再保留了。</p><p><a href="https://www.codewars.com/users/evk" target="_blank" rel="noopener">evk</a>, <a href="https://www.codewars.com/users/niweic" target="_blank" rel="noopener">niweic</a>, <a href="https://www.codewars.com/users/marek_mistrzuk" target="_blank" rel="noopener">marek_mistrzuk</a></p><pre><code class="javascript">function chain(fns) {  let Chain = function(val){    this.execute = () =&gt; val;  };  for(let i in fns) Chain.prototype[i] = function (a, b) {    let val = this.execute(),        args = val === null ? [a, b] : [val, a];    return new Chain(fns[i](...args));  }  return new Chain(null);}</code></pre><p>参考文章：</p><ul><li><a href="https://stackoverflow.com/questions/115548/why-is-isnannull-false-in-js" target="_blank" rel="noopener">Why is isNaN(null) == false in JS?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;对于 Object 的遍历；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Function composition is a powerful technique. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function sum(x, y) {
  return x + y;
}

function double(x) {
  return sum(x, x);
}

function minus (x, y) {
  return x - y;
}

function addOne(x) {
  return sum(x, 1);
}

double(sum(2, 3)); // 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But in complex expressions, composition may be difficult to understand. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;double(double(addOne(sum(7, minus(sum(5, sum(4, 5)), 4))))); // 72
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this kata, we will implement a function that allows us to perform this by applying a fluid style:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;c.sum(4, 5).sum(5).minus(4).sum(7).addOne().double().double().execute(); // 72
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Your job is implement the &lt;code&gt;chain&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function chain(fns) {
}

var c = chain({sum: sum, minus: minus, double: double, addOne: addOne});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, this function receives the methods to be chained and returns an object that allows you to call the chained methods. The result is obtained by calling the &lt;code&gt;execute&lt;/code&gt;method.&lt;/p&gt;
&lt;p&gt;Chained functions receive an arbitrary number of arguments. The first function in the chain receives all its arguments. In the other functions, the first argument is the result of the previous function and then it only receives the remainder arguments (second, third, etc.). The tests always pass the appropriate arguments and you do not have to worry about checking this.&lt;/p&gt;
&lt;p&gt;Note that the chain can be reused (the internal state is not stored):&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>象棋 (Xiangqi/Chinese Chess) Board Validator | 4kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/06/10/%E8%B1%A1%E6%A3%8B%20(XiangqiChinese%20Chess)%20Board%20Validator%20%7C%204kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/06/10/象棋 (XiangqiChinese Chess) Board Validator | 4kyu/</id>
    <published>2018-06-10T03:54:25.832Z</published>
    <updated>2019-01-22T15:18:52.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Your friend recently has shown you some chess puzzles he found somewhere. It’s not your ordinary chess: but the mysterious, distinct relative of chess, the legendary <a href="http://www.wikiwand.com/en/Xiangqi" target="_blank" rel="noopener">象棋</a>, also known as Xiangqi/Chinese chess! As a Chinese, you know that your friend doesn’t know anything in Chinese besides recognizing a few sigils (for example, he doesn’t know what is <code>七步擒士</code> or <code>雙馬飲泉</code>), so it’s probably likely that the “puzzles” he got is actually bogus, and the pieces are not placed properly. However, you don’t want to actually teach him Xiangqi either (yet), so the best tactic you could come up with is to write a validator program and let your friend use it instead of using you.</p><hr><p>You will be given an ASCII board. Xiangqi board is 9 tiles wide and 10 tiles high, with the pieces placed as follows:</p><pre><code>Example (the starting Xiangqi board):車馬象士將士象馬車　　　｜Ｘ｜　　　　砲　＋－＋　砲　卒　卒　卒　卒　卒－－－－－－－－－－－－－－－－－－兵　兵　兵　兵　兵　炮　＋－＋　炮　　　　｜Ｘ｜　　　俥傌相仕帥仕相傌俥The bottom and top half corresponds to red and black pieces, respectively.Note that red and black have different characters to distinguish the same piece of both sides.</code></pre><p>Your function, <code>chessValidator</code>, should determine whether the pieces in argument <code>board</code> are placed legally. Unlike the chess you’re familiar with, there are restrictions as to where the various chess pieces can be at:</p><a id="more"></a><pre><code>俥/車, 傌/馬, 炮/砲 (2 max): no restrictions相/象 (2 max): they can only stay at 7 spots at their side of the board:－－Ｏ－－－Ｏ－－　　　　　　　　　Ｏ　　＋Ｏ＋　　Ｏ　　　｜Ｘ｜　　　　　Ｏ＋－＋Ｏ　　Don&#39;t let them go to the other side of the board: it&#39;s called 飛象過河, which is bad and you should feel bad about it.仕/士 (2 max): they can only stay at the center or the 4 corners of the 3x3 &quot;palace&quot; (九宮):－－－－－－－－－　　　　　　　　　　　　Ｏ－Ｏ　　　　　　｜Ｏ｜　　　　　　Ｏ－Ｏ　　　帥/將 (always 1): they can stay at every tile inside the palace, and nowhere else:－－－－－－－－－　　　　　　　　　　　　＋－＋　　　　　　｜Ｘ｜　　　　　　＋－＋　　　    // anywhere inside this 3x3 block is okayBecause they are your &quot;kings&quot; in Xiangqi, it is mandatory that one and only one exists.Additionally, 帥/將 cannot face each other vertically without any pieces inbetween:　　　＋將＋　　　　　　｜Ｘ｜　　　　　　＋－＋　　　　　　　　　　　　－－－－－－－－－－－－－－－－－－　　　　　　　　　　　　＋帥＋　　　　　　｜Ｘ｜　　　　　　＋－＋　　　  // this is illegal because they&#39;re directly facing each other at the same column兵/卒 (5 max): at their starting positions (look at the above starting board), they can only move forward. However, once they reached the other side, they can move sideways as well as moving forward, at least until they reach the last row of the opponent side (no falling back, though!):　　　　　　　　　－－－－兵－－－－－－－－－－－－兵兵　　　　　　　　The left and right 兵s can do nothing but moving forward. The center one, however, can move sideways since it has crossed the center line.(By the way, there is no such thing as pawn promotion in Xiangqi.)</code></pre><hr><p>You program should validate that:</p><ul><li>Number of pieces of each side is within their respective limits</li><li>The pieces are placed in a legal position</li><li>Said configuration is legal (in respect to 帥/將 and 兵/卒 rules). Note that we don’t care about whether it is practically reachable in-game, Xiangqi endgame puzzles can be pretty ridiculous at piece placements, and you might even start out being checked. We only care about whether it is legal. For example:</li></ul><pre><code>－－－－兵－兵－兵兵－－－－－－－－兵</code></pre><p>would be illegal because 兵 cannot move sideways before they go across the center row, which means the above configuration is fundamentally impossible.</p><p>You can assume that the board will always be well-formatted. Always assume red is at the bottom.</p><p>See example test cases for some examples.</p><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="javascript">function chessValidator(board) {    let b = board.split(&#39;\n&#39;).map(x =&gt; x.split(&#39;&#39;));    // check the number of 俥/車, 傌/馬, 炮/砲    let chariot1 = chessIndex(b, &#39;車&#39;);    let chariot2 = chessIndex(b, &#39;俥&#39;);    let horse1 = chessIndex(b, &#39;馬&#39;);    let horse2 = chessIndex(b, &#39;傌&#39;);    let cannon1 = chessIndex(b, &#39;砲&#39;);    let cannon2 = chessIndex(b, &#39;炮&#39;);    let elep1 = chessIndex(b, &#39;象&#39;);    let elep2 = chessIndex(b, &#39;相&#39;);    let advisor1 = chessIndex(b, &#39;士&#39;);    let advisor2 = chessIndex(b, &#39;仕&#39;);    let two = [chariot1, chariot2, horse1, horse2,cannon1,cannon2, elep1, elep2, advisor1, advisor2];    for (var i = 0; i &lt; two.length; i++) {        if (two[i].length &gt; 2) {            console.log(&#39;over two pieces for the same kind&#39;)            return false;        }    }    // 相/象    let elep1T = [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]];    let elep2T = [[9,2], [9,6], [7,0], [7,4], [7,8], [5,2], [5,6]];    for (var i = 0; i &lt; elep1.length; i++) {        if(!isArrayInArray(elep1T,elep1[i])) {            console.log(&#39;象 at the wrong position&#39;)            return false;        }    }    for (var i = 0; i &lt; elep2.length; i++) {        if(!isArrayInArray(elep2T,elep2[i])) {            console.log(&#39;相 at the wrong position&#39;)            return false;        }    }    // 仕/士    let advisor1T = [[0,3], [0,5], [1,4], [2,3], [2,5]]    let advisor2T = [[9,3], [9,5], [8,4], [7,3], [7,5]]    for (var i = 0; i &lt; advisor1.length; i++) {        if(!isArrayInArray(advisor1T,advisor1[i])) {            console.log(&#39;士 at the wrong position&#39;)            return false;        }    }    for (var i = 0; i &lt; advisor2.length; i++) {        if(!isArrayInArray(advisor2T,advisor2[i])) {            console.log(&#39;仕 at the wrong position&#39;)            return false;        }    }    // 兵/卒    let soldier1 = chessIndex(b, &#39;卒&#39;);    let soldier2 = chessIndex(b, &#39;兵&#39;);    for (var i = 0; i &lt; soldier1.length; i++) {        if (soldier1[i][0] &lt; 3) {            console.log(&#39;卒 at the wrong position&#39;)            return false;        } else if(soldier1[i][0] &lt; 5 &amp;&amp; soldier1[i][1] % 2 === 1 ) {            console.log(&#39;卒 at the wrong position&#39;)            return false;        }    }    for (var i = 0; i &lt; soldier2.length; i++) {        if (soldier2[i][0] &gt; 6) {            console.log(&#39;兵 at the wrong position&#39;)            return false;        } else if(soldier2[i][0] &gt; 4 &amp;&amp; soldier2[i][1] % 2 === 1 ) {            console.log(&#39;兵 at the wrong position&#39;)            return false;        }    }    for (var i = 0; i &lt; 9; i++) {        if(b[3][i] === &#39;卒&#39; &amp;&amp; b[4][i] === &#39;卒&#39;) {            console.log(&#39;卒 at the wrong position&#39;)            return false;        }        if(b[5][i] === &#39;兵&#39; &amp;&amp; b[6][i] === &#39;兵&#39;) {            console.log(&#39;兵 at the wrong position&#39;)            return false;        }    }    // 帥/將    let general1 = chessIndex(b, &#39;將&#39;);    let general2 = chessIndex(b, &#39;帥&#39;);    if (general1.length !== 1 || general2.length !== 1) {        console.log( &#39;帥/將 lost &#39;)        return false;    }    if (general1[0][0] &gt; 2 ||        general1[0][1] &lt; 3 ||        general1[0][1] &gt; 5 ||        general2[0][0] &lt; 7 ||        general2[0][1] &lt; 3 ||        general2[0][1] &gt; 5) {        console.log( &#39;帥/將 at the wrong position &#39;)        return false;    }    if(general1[0][1] === general2[0][1]) {        let k = general1[0][1]        for (var i = general1[0][0]+1; i &lt; general2[0][0]; i++) {            if (b[i][k] !== &#39;Ｘ&#39; &amp;&amp;                b[i][k] !== &#39;－&#39; &amp;&amp;                b[i][k] !== &#39;　&#39; &amp;&amp;                b[i][k] !== &#39;｜&#39; &amp;&amp;                b[i][k] !== &#39;＋&#39;) {                break;            }        }        if(i === general2[0][0]) {            console.log(&#39;帥/將 are directly facing each other at the same column&#39;)            return false;        }    }    //if a flipped starting board    return true;}function chessIndex(b, s) {    let res = [];    for (var i = 0; i &lt; b.length; i++) {        let k = -1;        while((k = b[i].indexOf(s,k+1)) !== -1) {            res.push([i,k]);        }    }    return res;}function isArrayInArray(arr, item){  var item_as_string = JSON.stringify(item);  var contains = arr.some(function(ele){    return JSON.stringify(ele) === item_as_string;  });  return contains;}</code></pre><p>主要讲一下重复用到的两个 function 吧，一个是 <code>chessIndex()</code> 来得到棋盘上某个棋子的坐标，输出的是一个二维 array。另一个 <code>isArrayInArray(arr, item)</code> ，arr 是一个二维 array，item 是一个 array，检测 item 是否再 arr 里面。</p><p><code>chessIndex()</code> 难点在与处理一行内重复的元素。比如:</p><pre><code class="javascript">&gt;a = a.split(&quot;&quot;)[ &#39;　&#39;, &#39;砲&#39;, &#39;　&#39;, &#39;＋&#39;, &#39;－&#39;, &#39;＋&#39;, &#39;　&#39;, &#39;砲&#39;, &#39;　&#39; ]&gt;a.indexOf(&#39;砲&#39;)1&gt;a.indexOf(&#39;砲&#39;,2)7&gt;</code></pre><p>这里 array 中含有两个 <code>&#39;砲&#39;</code>。要获取第二个 <code>&#39;砲&#39;</code>，就要给 <code>indexOf()</code> 加上第二个参数。</p><p><code>isArrayInArray()</code> 方法中用到 <code>JSON.stringfy</code>：</p><pre><code class="javascript">&gt;a = [[1,2],[2,3]][ [ 1, 2 ], [ 2, 3 ] ]&gt;JSON.stringify(a)&#39;[[1,2],[2,3]]&#39;&gt;obj = { &quot;name&quot;:&quot;John&quot;, &quot;age&quot;:30, &quot;city&quot;:&quot;New York&quot;};{ name: &#39;John&#39;, age: 30, city: &#39;New York&#39; }&gt;JSON.stringify(obj)&#39;{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;}&#39;&gt;obj = { &quot;name&quot;:&quot;John&quot;, &quot;today&quot;:new Date(), &quot;city&quot;:&quot;New York&quot;};{ name: &#39;John&#39;,  today: 2018-06-10T03:44:24.742Z,  city: &#39;New York&#39; }&gt;JSON.stringify(obj)&#39;{&quot;name&quot;:&quot;John&quot;,&quot;today&quot;:&quot;2018-06-10T03:44:24.742Z&quot;,&quot;city&quot;:&quot;New York&quot;}&#39;&gt; obj = { &quot;name&quot;:&quot;John&quot;, &quot;age&quot;:function () {return 30;}, &quot;city&quot;:&quot;New York&quot;};{ name: &#39;John&#39;, age: [Function: age], city: &#39;New York&#39; }&gt;JSON.stringify(obj)&#39;{&quot;name&quot;:&quot;John&quot;,&quot;city&quot;:&quot;New York&quot;}&#39;&gt;obj.age = obj.age.toString()&#39;function () {return 30;}&#39;&gt;obj { name: &#39;John&#39;,  age: &#39;function () {return 30;}&#39;,  city: &#39;New York&#39; }&gt;JSON.stringify(obj)&#39;{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:&quot;function () {return 30;}&quot;,&quot;city&quot;:&quot;New York&quot;}&#39;&gt;</code></pre><p>上面的例子，后面一大部分摘自 <a href="https://www.w3schools.com/js/js_json_stringify.asp" target="_blank" rel="noopener">JSON.stringify()</a>，可以看到，可以把  array，object 等直接转化成 string。最后两个例子是讲，如果 object 中包含函数，则会被忽略。</p><p>用到了 <code>some()</code> 方法，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">MDN docs</a> 给出的解释：</p><blockquote><p>The <code>some()</code> method tests whether at least one element in the array passes the test implemented by the provided function.</p></blockquote><p>上述两个函数方法的构造是关键。在这两个函数的基础上，对棋盘的棋子进行依此按照相应的的规则进行检测，剩下的只是一些比较繁琐的工作，和细节上的修饰。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Your friend recently has shown you some chess puzzles he found somewhere. It’s not your ordinary chess: but the mysterious, distinct relative of chess, the legendary &lt;a href=&quot;http://www.wikiwand.com/en/Xiangqi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;象棋&lt;/a&gt;, also known as Xiangqi/Chinese chess! As a Chinese, you know that your friend doesn’t know anything in Chinese besides recognizing a few sigils (for example, he doesn’t know what is &lt;code&gt;七步擒士&lt;/code&gt; or &lt;code&gt;雙馬飲泉&lt;/code&gt;), so it’s probably likely that the “puzzles” he got is actually bogus, and the pieces are not placed properly. However, you don’t want to actually teach him Xiangqi either (yet), so the best tactic you could come up with is to write a validator program and let your friend use it instead of using you.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;You will be given an ASCII board. Xiangqi board is 9 tiles wide and 10 tiles high, with the pieces placed as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example (the starting Xiangqi board):

車馬象士將士象馬車
　　　｜Ｘ｜　　　
　砲　＋－＋　砲　
卒　卒　卒　卒　卒
－－－－－－－－－
－－－－－－－－－
兵　兵　兵　兵　兵
　炮　＋－＋　炮　
　　　｜Ｘ｜　　　
俥傌相仕帥仕相傌俥

The bottom and top half corresponds to red and black pieces, respectively.
Note that red and black have different characters to distinguish the same piece of both sides.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Your function, &lt;code&gt;chessValidator&lt;/code&gt;, should determine whether the pieces in argument &lt;code&gt;board&lt;/code&gt; are placed legally. Unlike the chess you’re familiar with, there are restrictions as to where the various chess pieces can be at:&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Argument Mapper | 5kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/06/07/Argument%20Mapper%20%7C%205kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/06/07/Argument Mapper | 5kyu/</id>
    <published>2018-06-07T07:32:38.890Z</published>
    <updated>2019-01-22T15:15:24.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>As part of a broader functionality you need to develop an argument mapper.</p><p>The function receives a function object as first parameter and an unknown number of arguments [zero to many]. You have to return an associative array that maps the name of an argument and its related value.</p><p>The usage is:</p><pre><code class="javascript">function func1(arg1, arg2) { ... }var map = createArgumentMap(func1,&#39;valueOfArg1&#39;, &#39;valueOfArg2&#39;);console.log(map[&#39;arg1&#39;]);  // writes &#39;valueOfArg1&#39;console.log(map[&#39;arg2&#39;]);  // writes &#39;valueOfArg2&#39;</code></pre><p>The passed values are in the same order as they appear in the function object.</p><p>Invalid inputs, e.g. non-function objects, or wrong number of arguments, are not considered.</p><p>Hajime!</p><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="javascript">function createArgumentMap(func) {    // create an argument map and return it    let args = Array.prototype.slice.call(arguments,1);    let res = {};    for (var i = 1; i &lt;= args.length; i++) {        res[&#39;a&#39; + i] = args[i-1]    }    return res  }</code></pre><p>关于 JavaScript 中 arguments 的性质参看：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">Arguments object</a></p><p><code>res[&#39;a&#39;+i]</code> 是为了契合 test 中都是用形如 map[a1] map[a2] 等来 check 答案的。这里我的方法有些取巧。实际上需要得到的是实际定义函数时使用的参数名称，就像上次 review 中那样，要用到 <code>.toString()</code> 和正则表达式。</p><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p><a href="https://www.codewars.com/users/colbydauph" target="_blank" rel="noopener">colbydauph</a></p><pre><code class="javascript">function createArgumentMap(func) {  var args = (/function\s[^(]*\(([^)]+)\)/g.exec(func.toString()) || [&#39;&#39;]).pop().split(/,/g);  return Array.prototype.slice.call(arguments, 1).reduce(function(p, c, i){ return p[args[i]] = c, p }, {});}</code></pre><p><code>reduce()</code> 中 callback 函数的三个参数，依次分别是 <code>accumulator</code>, <code>currentValue</code>, <code>currentIndex</code>。对应代码中的 <code>function(p, c, i){...}</code></p><p>正则表达式分析：</p><p><code>/function\s[^(]*\(([^)]+)\)/g</code></p><ul><li><code>/…/g</code> : 表明正则表达式 global 模式，找到所有可能的 match，而不是仅仅是找到第一个 mathc 就停下来。</li><li><code>function\s</code> : 以 function 开头，紧接着是一个 space 空格 <code>\s</code>。</li><li><code>[^(]*</code> : 0 个或多个非 <code>(</code> 的字符。</li><li><code>\(</code>: 匹配左括号 <code>(</code>。</li><li><code>([^)]+)</code>: 1个或多个非 <code>)</code> 的字符。注意这里用括号括住，那么输出匹配结果时也会把这个括号括住的匹配输出来。</li><li><code>\)</code>: 匹配右括号 <code>)</code>。</li></ul><pre><code class="javascript">&gt;(/function\s[^(]*\(([^)]+)\)/g.exec(func1.toString()))[ &#39;function func1(arg1, arg2)&#39;,  &#39;arg1, arg2&#39;,  index: 0,  input: &#39;function func1(arg1, arg2) { console.log(arg1, arg2) }&#39; ]&gt;(/function\s[^(]*\([^)]+\)/g.exec(func1.toString()))[ &#39;function func1(arg1, arg2)&#39;,  index: 0,  input: &#39;function func1(arg1, arg2) { console.log(arg1, arg2) }&#39; ]&gt;</code></pre><p>上述展示了加中间那对括号，和不加括号时的区别。</p><p>另外注意这里的 <code>.split(/,/g)</code> 方法的参数。这里的参数并不是两个。而是一个，一个正则表达式，global 模式匹配单字符 <code>,</code>，用正则表达式的 <code>/.../g</code> 扩起来。同理也可以写成 <code>.split(&#39;,&#39;)</code>。</p><p><code>.reduce()</code>方法使用及参数说明：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Array.prototype.reduce()</a></p><p>关于最后在 reduce 的 callback 函数中，return 那里出现的 comma，<code>return p[args[i]] = c, p</code>，其实就是多个语句的简写，先进行赋值，然后输出 <code>p</code>。参见 stack overflow 上的解释：<a href="https://stackoverflow.com/questions/10284536/return-statement-with-multiple-comma-separated-values" target="_blank" rel="noopener">return statement with multiple comma separated values</a></p><blockquote><p>It’s the <a href="http://es5.github.com/#x11.14" target="_blank" rel="noopener">comma operator</a>. It runs a series of expressions, in order, and then returns the result of the <em>last</em> of them.  </p></blockquote><p><a href="https://www.codewars.com/users/stnever" target="_blank" rel="noopener">stnever</a></p><pre><code class="javascript">function createArgumentMap(func) {  var argumentNames = getArgumentNames(func);  var argumentValues = arguments;  var result = {};  argumentNames.forEach(function(key, index) {    result[key] = argumentValues[index+1];      });  return result;}// shamelessly copied from http://stackoverflow.com/questions/1007981var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;var ARGUMENT_NAMES = /([^\s,]+)/g;function getArgumentNames(func) {  var fnStr = func.toString().replace(STRIP_COMMENTS, &#39;&#39;)  var result = fnStr.slice(fnStr.indexOf(&#39;(&#39;)+1, fnStr.indexOf(&#39;)&#39;)).match(ARGUMENT_NAMES)  if(result === null)     result = []  return result}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;As part of a broader functionality you need to develop an argument mapper.&lt;/p&gt;
&lt;p&gt;The function receives a function object as first parameter and an unknown number of arguments [zero to many]. You have to return an associative array that maps the name of an argument and its related value.&lt;/p&gt;
&lt;p&gt;The usage is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function func1(arg1, arg2) { ... }

var map = createArgumentMap(func1,&amp;#39;valueOfArg1&amp;#39;, &amp;#39;valueOfArg2&amp;#39;);
console.log(map[&amp;#39;arg1&amp;#39;]);  // writes &amp;#39;valueOfArg1&amp;#39;
console.log(map[&amp;#39;arg2&amp;#39;]);  // writes &amp;#39;valueOfArg2&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The passed values are in the same order as they appear in the function object.&lt;/p&gt;
&lt;p&gt;Invalid inputs, e.g. non-function objects, or wrong number of arguments, are not considered.&lt;/p&gt;
&lt;p&gt;Hajime!&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Default Arguments | 4kyu</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/06/05/Default%20Arguments%20%7C%204kyu/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/06/05/Default Arguments | 4kyu/</id>
    <published>2018-06-05T08:56:46.278Z</published>
    <updated>2019-01-22T15:14:34.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Write a function <code>defaultArguments</code>. It takes a function as an argument, along with an object containing default values for that function’s arguments, and returns another function which defaults to the right values. </p><p>You cannot assume that the function’s arguments have any particular names.</p><p>You should be able to call <code>defaultArguments</code> repeatedly to change the defaults.</p><pre><code class="javascript">function add(a,b) { return a+b;};var add_ = defaultArguments(add,{b:9});add_(10); // returns 19add_(10,7); // returns 17add_(); // returns NaNadd_ = defaultArguments(add_,{b:3, a:2});add_(10); // returns 13 nowadd_(); // returns 5add_ = defaultArguments(add_,{c:3}); // doesn&#39;t do anything, since c isn&#39;t an argumentadd_(10); // returns NaNadd_(10,10); // returns 20</code></pre><p>HINT: This problem requires using <code>Fuction.prototype.toString()</code> in order to extract a function’s argument list</p><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="javascript">function defaultArguments(func, params) {    // get the properties list of params    let defArg = Object.keys(params);    // use Function.prototype.toString() to get the arguments list    let args = func.args || func.toString().replace(/\/\/.*$|\/\*.*?\*\/|\s/gm, &#39;&#39;).match(/(?:[\w]+(?:,[\w]+)*)?(?=\))/m)[0].split(&#39;,&#39;);    // pass the properties into func    let newArgs = {};    for (var i = 0; i &lt; defArg.length; i++) {        if (args.indexOf(defArg[i]) &gt; -1) {            let idx = args.indexOf(defArg[i]);            newArgs[idx] = params[defArg[i]];        }    }    // bind the func and params into a new function    let detour = function() {                let argsArray = [].slice.call(arguments);                let x = Object.keys(newArgs);                for (var i = 0; i &lt; x.length; i++) {                    if(x[i] &gt;= argsArray.length) {                        argsArray[x[i]] = newArgs[x[i]];                    }                }                return func.apply(this,argsArray);            }    detour.args = args;    return detour;}</code></pre><p><code>args</code> 那一大串正则表达式，获得的是原函数的参数列表，是一个 array。<code>defArg</code> 是函数 <code>defaultArguments()</code> 预先给定的参数。将两者合并成新的参数 <code>newArgs</code> ，类型为 object。</p><p>举例说明，如果 <code>params</code> 传入的值是 <code>{ b: 3, a: 2 }</code>，那么经过中间 10 行到 16 行的循环运算得到的 <code>newArgs</code> 值是 <code>{ &#39;0&#39;: 2, &#39;1&#39;: 3 }</code>。</p><p>20 行 <code>argsArray = [].slice.call(arguments);</code>作用是打印参数列表。举例说明：</p><pre><code class="javascript">&gt;function add(a,b) { console.log([].slice.call(arguments));return a+b;};undefined&gt;add(1,2)[ 1, 2 ]3&gt;add(1,2,3)[ 1, 2, 3 ]3&gt;add(1,2,3,4)[ 1, 2, 3, 4 ]3</code></pre><p>因为整个函数最后 return 的是 detour。也就是说当第一次运行 <code>defaultArguments()</code> 时，仅仅是声明了 <code>detour()</code> 函数但是并没有运行。按照 details 里给出的例子，只有当 <code>add_(10)</code> 调用时， <code>detour()</code> 函数才真正被运行。此时的 <code>arguments</code> 值为 <code>[10]</code>。</p><p>27 行 <code>apply()</code> 方法的应用，就是调取 <code>func</code> 函数，并给他特定的 arguments 值，并获得结果。第一个参数是修改 <code>func</code> 函数的 <code>this</code> 指向的， 是 <code>this</code> 还是 <code>null</code> 对结果都是没有影响的。<a href="https://stackoverflow.com/questions/9644044/javascript-this-pointer-within-nested-function" target="_blank" rel="noopener">因为都是对函数的直接调用，不存在对某个 object 的 method 进行调用。</a></p><p>注意第 29 行的，函数也是 object，而且这个定义使得返回的函数对象多携带了 args 信息。这一点当时自己没有想到，也是看了答案后才明白的。</p><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p> <a href="https://www.codewars.com/users/mrkishi" target="_blank" rel="noopener">mrkishi</a>, <a href="https://www.codewars.com/users/guyingll" target="_blank" rel="noopener">guyingll</a>, <a href="https://www.codewars.com/users/iphp" target="_blank" rel="noopener">iphp</a>, <a href="https://www.codewars.com/users/willin" target="_blank" rel="noopener">willin</a>, <a href="https://www.codewars.com/users/marek_mistrzuk" target="_blank" rel="noopener">marek_mistrzuk</a></p><pre><code class="javascript">function defaultArguments(func, params) {  var names = func.names || func.toString()    .replace(/\/\/.*$|\/\*.*?\*\/|\s/gm, &#39;&#39;)    .match(/(?:[\w]+(?:,[\w]+)*)?(?=\))/m)[0].split(&#39;,&#39;);  var detour = function () {    var input = arguments;    return func.apply(this, names.map(function (val, i) {      return i &lt; input.length ? input[i] : params[names[i]];    }));  };  detour.names = names;  return detour;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Write a function &lt;code&gt;defaultArguments&lt;/code&gt;. It takes a function as an argument, along with an object containing default values for that function’s arguments, and returns another function which defaults to the right values. &lt;/p&gt;
&lt;p&gt;You cannot assume that the function’s arguments have any particular names.&lt;/p&gt;
&lt;p&gt;You should be able to call &lt;code&gt;defaultArguments&lt;/code&gt; repeatedly to change the defaults.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function add(a,b) { return a+b;};

var add_ = defaultArguments(add,{b:9});
add_(10); // returns 19
add_(10,7); // returns 17
add_(); // returns NaN

add_ = defaultArguments(add_,{b:3, a:2});
add_(10); // returns 13 now
add_(); // returns 5

add_ = defaultArguments(add_,{c:3}); // doesn&amp;#39;t do anything, since c isn&amp;#39;t an argument
add_(10); // returns NaN
add_(10,10); // returns 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HINT: This problem requires using &lt;code&gt;Fuction.prototype.toString()&lt;/code&gt; in order to extract a function’s argument list&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES5 Generators(i) 和闭包 closure</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/02/18/Codewars.com%20%7C%20ES5%20Generators(i)/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/02/18/Codewars.com | ES5 Generators(i)/</id>
    <published>2018-02-18T06:37:13.949Z</published>
    <updated>2019-01-18T14:30:30.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kata"><a href="#Kata" class="headerlink" title="Kata"></a>Kata</h2><p>Description:</p><p>This is the first part of three (<a href="http://www.codewars.com/kata/es5-generators-ii" target="_blank" rel="noopener">part2</a>, <a href="http://www.codewars.com/kata/es5-generators-iii" target="_blank" rel="noopener">part3</a>).</p><p>Generators and Iterators are new ES6 features that will allow things like this:</p><pre><code class="javascript">function* fibonacci() {    let [prev, curr] = [0, 1];    for (;;) {        [prev, curr] = [curr, prev + curr];        yield curr;    }}</code></pre><p>Using them in this way, we can do amazing things:</p><pre><code class="javascript">let seq = fibonacci();print(seq.next()); // 1print(seq.next()); // 2print(seq.next()); // 3print(seq.next()); // 5print(seq.next()); // 8</code></pre><p>This is powerful, but until a few months later, ES6 will not be born.</p><p>The goal of this kata is to implement pseudo-generators with ES5.</p><a id="more"></a><p>The first thing to do is to implement the generator function:</p><pre><code class="javascript">function generator(sequencer) {   ...}</code></pre><p><code>generator(sequencer[, arg1, arg2, …])</code> receives a sequencer function to generate the sequence and returns and object with a <code>next()</code> method. When the <code>next()</code> method is invoked, the next value is generated. The method could receive as well optional arguments to be passed to the sequencer function.</p><p>This is an example of a dummy sequencer:</p><pre><code class="javascript">function dummySeq() {  return function() {    return &quot;dummy&quot;;  };}</code></pre><p>To test generator(), you could use <code>dummySeq()</code> in this way:</p><pre><code class="javascript">var seq = generator(dummySeq);seq.next(); // &#39;dummy&#39;seq.next(); // &#39;dummy&#39;seq.next(); // &#39;dummy&#39;....</code></pre><p>When you’re done, you should implement the following generators (I think the functions are self explanatory):</p><pre><code class="javascript">function factorialSeq() {...} // 1, 1, 2, 6, 24, ...function fibonacciSeq() {...} // 1, 1, 2, 3, 5, 8, 13, ...function rangeSeq(start, step) {...} // rangeSeq(1, 2)  -&gt; 1, 3, 5, 7, ...function primeSeq() {...} // 2, 3, 5, 7, 11, 13, ...partialSumSeq(1, 3, 7, 2, 0) {...} // 1, 4, 11, 13, 13, end</code></pre><p>You can use any of them in the same way:</p><pre><code class="javascript">var seq = generator(factorialSeq);seq.next(); // !0 = 1seq.next(); // !1 = 1seq.next(); // !2 = 2seq.next(); // !3 = 6seq.next(); // !4 = 24...</code></pre><p>There are some sequences which are infinite and others are not. For example:</p><ul><li>primeSeq: Is infinite</li><li>partialSumSeq: Is limited to the passed values.</li></ul><p>When the sequence is done (in finite sequences), if you call seq.next() again, it should produce an error.</p><p>Good luck!</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>题目的大体含义是想要通过 ES5 来模拟 ES6 中才有的 generator 生成器功能。主要思路就是使用闭包 closure 这一特性：</p><pre><code class="javascript">function generator(sequencer) {    var args = Array.prototype.slice.call(arguments, 1);    return {        next: sequencer.apply(this,args)    };}function fibonacciSeq() {    var prev = 0    var current = 1    return function() {        var old = current        current = prev + current        prev = old        return prev    }}// 直接调用console.log(fibonacciSeq()())// 使用 closurevar seq = fibonacciSeq()console.log(seq())</code></pre><p>关于 Closure，非常推荐阅读 Kyle Simpson 写的 <em>You Don’t Know JS: Scope &amp; Closures</em> ，不到 100 页的小册子，由浅入深，通俗易懂。Closure 简单来讲，就是在一个函数内部定义一个嵌套的子函数，并 return 它，return 这个子函数。形式就像上面代码，在 <code>fibonacciSeq()</code> 函数里 return 了一个 anonymous function，匿名函数。这样做的好处就是，把 <code>fibonacciSeq()</code> 私有变量 <code>prev</code>, <code>current</code> 保护起来，<strong>同时又能通过返回的 anonymous function 去修改函数的私有变量</strong>。听起来很绕。很实用，因为一般来讲，我们是无法在函数的外部去修改一个函数内部的私有变量的，但 closure 却可以。或者换句话，通过「在函数 A 中返回一个子函数」这样的操作，可以去修改函数 A 的私有变量。</p><p>这里关于 closure，主要想提及几个点：</p><p>一、<code>fibonacciSeq()()</code> 和 <code>seq()</code> 区别</p><p>二者函数的调用和执行都不同。<code>fibonacciSeq()()</code> 则是先调用函数 <code>fibonacciSeq()</code>，该函数返回一个匿名函数，再继续调用该匿名函数，得到匿名函数的返回值。所以是连续调用了两个函数，外层函数和内层函数，整个 <code>fibonacciSeq()</code> 函数中的语句都被执行了。</p><p>而使用 closure，首先定义变量 <code>var seq = fibonacciSeq()</code>，然后在调用 <code>seq()</code> 的过程中，仅仅调用执行了 <code>fibonacciSeq()</code> 里内部返回的的匿名函数，换句话说，在执行 <code>seq()</code> 的过程中， <code>fibonacciSeq()</code>  函数并没有被调用执行，整个过程真正调用执行的<strong>只有</strong>被嵌套的内层子函数，也就是返回的匿名函数，anonymous function。</p><p>这么一个简单区别就造成了，前者 <code>fibonacciSeq()()</code> 即便调用无数次，输出结果都是相同的，都是 <code>1</code>。而后者调用多次，却能够得到 Fibonacci 数列 <code>1,1,2,3,5…</code>。原因就在于 closure，虽然仅仅执行了匿名函数，但因为匿名函数是作为子函数存在于  <code>fibonacciSeq()</code>  函数内，所以根据 Lexical scope 的规则，内层函数是可以 access 到外层函数的变量的。所以在执行 <code>seq()</code> 的过程中，程序从内到外寻找变量  <code>prev</code>, <code>current</code>， 不仅在 <code>fibonacciSeq()</code>  找到了它的私有变量  <code>prev</code>, <code>current</code> ，而且还修改了它们的值！被修改了值的私有变量依旧保持在原来位置，即仍然作为函数的私有变量存在。这一点在文章 <a href="https://javascript.info/closure" target="_blank" rel="noopener">Closure - The Modern JavaScript Tutorial</a> 中有梗详细的解释，这里就不赘述了。</p><p>二、其他一些细节</p><p>在 <code>generator()</code> 中使用的 <code>call()</code> <code>apply()</code> 方法，主要是为了函数传参。 </p><ul><li><code>Array.prototype.slice.call(arguments, 1)</code> </li></ul><p>因为 <code>arguments</code> 是一个 array-like object，而不是真正的 array，所以无法使用 array 的诸多方法，包括 slice。<code>call()</code> 的作用就是让 <code>arguments</code> 用上 slice 方法。在这里去掉了  <code>arguments</code> 里的第一个元素，剩下元素作为一个新的 array 存储到 <code>args</code> 中。</p><ul><li><code>sequencer.apply(this,args)</code></li></ul><p>绑定 this 到 <code>sequencer</code> 并将参数 <code>args</code> 传递到函数中。</p><p>参考：</p><ul><li><a href="https://www.quora.com/What-are-the-reasons-to-use-return-function-in-JavaScript" target="_blank" rel="noopener">What are the reasons to use ‘return function’ in JavaScript? - Quora</a></li><li><a href="https://javascript.info/closure" target="_blank" rel="noopener">Closure - The Modern JavaScript Tutorial</a> ✪</li><li>You Don’t Know JS: Scope &amp; Closures - Kyle Simpson</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kata&quot;&gt;&lt;a href=&quot;#Kata&quot; class=&quot;headerlink&quot; title=&quot;Kata&quot;&gt;&lt;/a&gt;Kata&lt;/h2&gt;&lt;p&gt;Description:&lt;/p&gt;
&lt;p&gt;This is the first part of three (&lt;a href=&quot;http://www.codewars.com/kata/es5-generators-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;part2&lt;/a&gt;, &lt;a href=&quot;http://www.codewars.com/kata/es5-generators-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;part3&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Generators and Iterators are new ES6 features that will allow things like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function* fibonacci() {
    let [prev, curr] = [0, 1];
    for (;;) {
        [prev, curr] = [curr, prev + curr];
        yield curr;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using them in this way, we can do amazing things:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let seq = fibonacci();
print(seq.next()); // 1
print(seq.next()); // 2
print(seq.next()); // 3
print(seq.next()); // 5
print(seq.next()); // 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is powerful, but until a few months later, ES6 will not be born.&lt;/p&gt;
&lt;p&gt;The goal of this kata is to implement pseudo-generators with ES5.&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Wrapped Function</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/02/12/Codewars.com%20%7C%20Wrapped%20Function/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/02/12/Codewars.com | Wrapped Function/</id>
    <published>2018-02-12T01:59:34.004Z</published>
    <updated>2019-01-18T14:32:07.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kata"><a href="#Kata" class="headerlink" title="Kata"></a>Kata</h2><p>Create a function method that allow you to wrap an existing function. The method signature would look something like this:</p><p><strong>Usage Example</strong>:</p><pre><code class="javascript">function speak(name){   return &quot;Hello &quot; + name;}speak = speak.wrap(function(original, yourName, myName){   greeting = original(yourName);   return greeting + &quot;, my name is &quot; + myName;})var greeting = speak(&quot;Mary&quot;, &quot;Kate&quot;);</code></pre><a id="more"></a><p>这个题目就是给函数扩展一个 <code>wrap</code> 方法，wrap 本意是「包裹」，这里可以理解为，在原由函数功能的基础上，再次添加新的功能，可以视为对原有函数的一种增强。在本例中，<code>speak</code> 是一个简单函数，通过 <code>wrap</code> 方法，使之在 <code>speak</code> 基础之上，增加了 greeting 的功能。</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="1-that-this"><a href="#1-that-this" class="headerlink" title="1. that = this"></a>1. that = this</h3><pre><code class="javascript">Function.prototype.wrap = function(fn) {    var that = this;    return function(arg2,arg3) {        return fn(that,arg2,arg3);    };}</code></pre><p>因为 <code>wrap</code> 方法的参数是一个 callback 函数，其中 <code>original</code> 参数是要能够映射到原函数中才行。这里涉及到 <code>this</code> keyword, scope 以及函数调用的问题。</p><p>在 JavaScript 中，函数调用有三种情况：</p><ol><li><code>fn(arg)</code></li><li><code>obj.child.method(arg)</code></li><li><code></code>fn.call(context,arg)`</li></ol><p>但其实第三种调用方法才是最通用的书写形式，前两种都可以用第三种书写形式写出来，比如第一种，可以写成 <code>fn.call(undefined,arg)</code>， 第二种可以写成 <code>obj.child.method.call(obj.child,arg)</code> 。因此当 <code>wrap</code> 作为函数的方法被函数 <code>speak</code> 调用时，<code>this</code> 指代的为函数 <code>speak</code>。通过创建变量并赋值，将这种映射关系存储下来。</p><h3 id="2-bind"><a href="#2-bind" class="headerlink" title="2. bind()"></a>2. bind()</h3><pre><code class="javascript">Function.prototype.wrap = function(callback) {  return callback.bind(this, this);}</code></pre><p><code>bind()</code> 方法首先会创建一个新函数，这个新函数的函数体和 <code>callback</code> 保持一致。 <code>bind()</code> 方法本身可能带多个参数，第一个参数用于指定 <code>this</code> 的值，之后的参数作为「预制参数」传入到新函数中。预制参数的含义可以查阅文末的参考链接。</p><p>而在这个例子里，<code>bind()</code> 方法的参数是两个 <code>this</code>，第一个 <code>this</code> 仅仅指定 context，因为是 <code>speak()</code> 调用的 <code>wrap()</code>，所以 <code>this</code> 就指向 <code>speak()</code>。 第二个 <code>this</code> 则作为 <code>callback</code> 函数第一个参数的预制参数，即参数 <code>original</code>。所以 <code>original</code> 表示函数 <code>speak()</code>。剩余参数则通过实参（实际调用时使用的参数）进行传入。为了便于理解其中的参数传递，可以试着做以下实验：</p><pre><code class="javascript">function speak(name){   return &quot;Hello &quot; + name;}Function.prototype.wrap = function(callback) {  return callback.bind(&#39;context&#39;,this, &#39;s&#39;, &#39;this&#39;);}speak = speak.wrap(function(original, yourName, myName){    console.log(original,yourName,myName)   return &quot;, my name is &quot; + myName;})console.log(speak(&quot;Mary&quot;, &quot;Kate&quot;)) //</code></pre><p>随意改变 <code>callback.bind()</code> 的参数值，查看对应的 <code>console.log(original,yourName,myName)</code> 的输出。可以找到规律，<code>bind()</code> 方法的第一个参数仅仅指定 context，对参数传递无影响。除了第一个之外的其他参数作为预制参数，影响参数传递。</p><p>tl;dr: </p><p><code>bind()</code> 方法第一个参数对应原函数( bound function )的 <code>this</code>，第二个参数对应原函数( bound function )的第一个参数，但三个参数对应原函数的第二个参数，以此类推。</p><h3 id="3-arrow-function"><a href="#3-arrow-function" class="headerlink" title="3. arrow function"></a>3. arrow function</h3><pre><code class="javascript">Function.prototype.wrap = function (f) {  return (...args) =&gt; f(this, ...args)};</code></pre><p><code>…args</code> 表明 rest paramaters，其余参数，字面意思很好理解。<code>=&gt;</code> 为 arrow function，类似 lambda 函数，这里 return 一个新函数，新函数的第一个参数值改为 <code>this</code>，其余参数作为实参传入。原理上这种方法也是类似于预制参数。</p><p>参考：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">this - MDN web docs</a></li><li><a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener">this 的值到底是什么？一次说清楚 - 方应杭</a></li><li><a href="https://github.com/Aaaaaaaty/Blog/issues/1">Javascript之bind #1( 预制参数 )</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/2">JavaScript深入之从原型到原型链 #2</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noopener">Rest parameters</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kata&quot;&gt;&lt;a href=&quot;#Kata&quot; class=&quot;headerlink&quot; title=&quot;Kata&quot;&gt;&lt;/a&gt;Kata&lt;/h2&gt;&lt;p&gt;Create a function method that allow you to wrap an existing function. The method signature would look something like this:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Usage Example&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function speak(name){
   return &amp;quot;Hello &amp;quot; + name;
}

speak = speak.wrap(function(original, yourName, myName){
   greeting = original(yourName);
   return greeting + &amp;quot;, my name is &amp;quot; + myName;
})

var greeting = speak(&amp;quot;Mary&amp;quot;, &amp;quot;Kate&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Catching Car Mileage Numbers</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2018/02/10/Codewars.com-%7C-Catching-Car-Mileage-Numbers/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2018/02/10/Codewars.com-|-Catching-Car-Mileage-Numbers/</id>
    <published>2018-02-10T02:38:00.740Z</published>
    <updated>2019-01-18T14:44:33.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kata"><a href="#Kata" class="headerlink" title="Kata"></a>Kata</h2><blockquote><p>  “7777…<em>8?!??!</em>“, exclaimed Bob, “I missed it again! Argh!” Every time there’s an interesting number coming up, he notices and then promptly forgets. Who <em>doesn’t</em> like catching those one-off interesting mileage numbers?</p></blockquote><p>Let’s make it so Bob <strong>never</strong> misses another interesting number. We’ve hacked into his car’s computer, and we have a box hooked up that reads mileage numbers. We’ve got a box glued to his dash that lights up yellow or green depending on whether it receives a <code>1</code> or a <code>2</code> (respectively).</p><p>It’s up to you, intrepid warrior, to glue the parts together. Write the function that parses the mileage number input, and returns a <code>2</code> if the number is “interesting” (see below), a <code>1</code> if an interesting number occurs within the next two miles, or a <code>0</code> if the number is not interesting.</p><a id="more"></a><p><strong>Note:</strong> In Haskell, we use <code>No</code>, <code>Almost</code> and <code>Yes</code> instead of <code>0</code>, <code>1</code> and <code>2</code>.</p><p> <strong>“Interesting” Numbers</strong></p><p>Interesting numbers are 3-or-more digit numbers that meet one or more of the following criteria:</p><ul><li>Any digit followed by all zeros: <code>100</code>, <code>90000</code></li><li>Every digit is the same number: <code>1111</code></li><li>The digits are sequential, incementing†: <code>1234</code></li><li>The digits are sequential, decrementing‡: <code>4321</code></li><li>The digits are a palindrome: <code>1221</code> or <code>73837</code></li><li>The digits match one of the values in the <code>awesomePhrases</code> array</li></ul><blockquote><p>  † For incrementing sequences, <code>0</code> should come after <code>9</code>, and not before  <code>1</code>, as in <code>7890</code>.<br>  ‡ For decrementing sequences, <code>0</code> should come after <code>1</code>, and not before  <code>9</code>, as in <code>3210</code>.</p></blockquote><p>So, you should expect these inputs and outputs:</p><pre><code class="javascript">// &quot;boring&quot; numbersisInteresting(3, [1337, 256]);    // 0isInteresting(3236, [1337, 256]); // 0// progress as we near an &quot;interesting&quot; numberisInteresting(11207, []); // 0isInteresting(11208, []); // 0isInteresting(11209, []); // 1isInteresting(11210, []); // 1isInteresting(11211, []); // 2// nearing a provided &quot;awesome phrase&quot;isInteresting(1335, [1337, 256]); // 1isInteresting(1336, [1337, 256]); // 1isInteresting(1337, [1337, 256]); // 2</code></pre><p><strong>Error Checking</strong></p><ul><li>A number is only interesting if it is greater than <code>99</code>!</li><li>Input will <em>always</em> be an integer greater than <code>0</code>, and less than <code>1,000,000,000</code>. </li><li>The <code>awesomePhrases</code> array will always be provided, and will always be an array, but may be empty. (Not <em>everyone</em> thinks numbers spell funny words…)</li><li>You should only ever output <code>0</code>, <code>1</code>, or <code>2</code>.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目很长，但总结起来，无非就是输入一个 number 类型的数据，检查是否符合上述列出的所谓「interesting number」的规则，按照规则输出 0，1 或 2。以下是自己看到的一个非常简洁的答案，答案来自 <a href="https://www.codewars.com/users/laoris" target="_blank" rel="noopener">laoris</a>, <a href="https://www.codewars.com/users/jwong483" target="_blank" rel="noopener">jwong483</a>, <a href="https://www.codewars.com/users/Marlen" target="_blank" rel="noopener">Marlen</a>：</p><pre><code class="javascript">function isInteresting(number, awesomePhrases) {  var tests = [    function(n) { return /^\d00+$/.test(n); },    function(n) { return /^(\d)\1+$/.test(n); },    function(n) { return RegExp(n).test(1234567890); },    function(n) { return RegExp(n).test(9876543210); },    function(n) { return n + &#39;&#39; == (n + &#39;&#39;).split(&#39;&#39;).reverse().join(&#39;&#39;); },    function(n) { return awesomePhrases.some(function(p) { return p == n; }); }  ];  var interesting = 0;  tests.some(function(test) {    if (number &gt; 99 &amp;&amp; test(number))      return interesting = 2;    else if ((number &gt; 98 &amp;&amp; test(number + 1)) || (number &gt; 97 &amp;&amp; test(number + 2)))      interesting = 1;  });  return interesting;}</code></pre><p>这个答案在代码结构上很厉害的一点在于，使用了 <code>some()</code> 这个函数，以及加上完全由函数组成的 array 数组，来进行给定规则的检验。 <code>some()</code> 方法主要用于测试数组中某些元素。用法就是在方法 <code>some()</code> 中定义一个 callback 回调函数，数组中的每一个元素作为回调函数的参数依次传入到回调函数中（回调函数的意思就是函数作为函数的参数，这里有点儿绕） 。</p><p>在这个例子里，<code>tests</code> 是事先定义好的数组，数组的每一个元素都是一个函数。对这个数组使用 <code>some()</code> 方法，在其中定义了一个回调函数，形如：</p><pre><code class="javascript">tests.some(function(test){    if（number &gt; 99 &amp;&amp; test(number)){        // code here    }    //code here})</code></pre><p>在实际执行过程中，<code>tests</code> 中的每一个元素 element，都会作为回调函数的参数 <code>test</code> 传递进回调函数中。因为 <code>tests</code>  数组里的元素都是函数，所以这里使用参数  <code>test</code>  时也是把它当作函数来使用的。因此才会看到有 <code>test(number)</code> 这样的语句。</p><p>关于 <code>some()</code> 方法，MDN 上给了一个更加简单的例子，来帮助理解这其中的参数传导：</p><pre><code class="javascript">function isBigEnough(element, index, array) {  return (element &gt;= 10);}var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true</code></pre><p>明白了整个算法的结构，其实在 <code>tests</code> 中定义的检测函数，也都非常巧妙。 </p><ul><li>形如 [1234, 8765] 这类数，把被检测数转化成 <code>RegExp</code> 逆向使用正则表达式；</li><li><code>n+&#39;&#39;</code> 把数字转化成数组；</li><li>检测 palindrome 回文数，使用 <code>reverse()</code> 方法，判断反转后是否相等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kata&quot;&gt;&lt;a href=&quot;#Kata&quot; class=&quot;headerlink&quot; title=&quot;Kata&quot;&gt;&lt;/a&gt;Kata&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  “7777…&lt;em&gt;8?!??!&lt;/em&gt;“, exclaimed Bob, “I missed it again! Argh!” Every time there’s an interesting number coming up, he notices and then promptly forgets. Who &lt;em&gt;doesn’t&lt;/em&gt; like catching those one-off interesting mileage numbers?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s make it so Bob &lt;strong&gt;never&lt;/strong&gt; misses another interesting number. We’ve hacked into his car’s computer, and we have a box hooked up that reads mileage numbers. We’ve got a box glued to his dash that lights up yellow or green depending on whether it receives a &lt;code&gt;1&lt;/code&gt; or a &lt;code&gt;2&lt;/code&gt; (respectively).&lt;/p&gt;
&lt;p&gt;It’s up to you, intrepid warrior, to glue the parts together. Write the function that parses the mileage number input, and returns a &lt;code&gt;2&lt;/code&gt; if the number is “interesting” (see below), a &lt;code&gt;1&lt;/code&gt; if an interesting number occurs within the next two miles, or a &lt;code&gt;0&lt;/code&gt; if the number is not interesting.&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://github.com/Reyshawn/reyshawn.github.io/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/Algorithm/"/>
    
      <category term="codewars" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/codewars/"/>
    
      <category term="JavaScript" scheme="https://github.com/Reyshawn/reyshawn.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 部署到新电脑</title>
    <link href="https://github.com/Reyshawn/reyshawn.github.io/2017/11/02/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/"/>
    <id>https://github.com/Reyshawn/reyshawn.github.io/2017/11/02/Hexo部署到新电脑/</id>
    <published>2017-11-02T14:53:17.000Z</published>
    <updated>2019-01-18T14:43:42.076Z</updated>
    
    <content type="html"><![CDATA[<p>换了新的电脑，想把在 hexo 上的部署文件转移到新电脑上。因为提前在 github 为此做了一些工作，就是按照网上一些朋友的建议，在 github 上创建两个分支，一个分支 「master」 用于 hexo 部署，另一个分支「hexo」用于存储源文件。这样当需要在一台新电脑上使用 hexo 时，只需要把源文件 clone 到本地就行了。但事情总不是一帆风顺😅。今天遇到的问题是，把源文件拉到本地以后，每次执行 <code>hexo d</code> 部署， 都会把所有源文件都部署到 <code>master</code> 分支上。按照常理，应该是只有 public 文件夹里的内容才会放在 <code>master</code> 分支下的。</p><a id="more"></a><p>在网上找了很多解决方案，最终认为还是 cache 出了问题。但只是去 <code>hexo clean</code> 并不起效。</p><p>解决办法：</p><p>首先是检查，github.io 仓库下默认分支是哪个，这里要把默认分支改成存储源文件的那个分支。在我的仓库下就是把默认分支改成 「hexo」。</p><p>再者，就是 <code>hexo clean</code>，然后把目录下的 <code>.deploy_git</code> 删掉。然后再重新进行 <code>hexo generate</code> 和 <code>hexo deploy</code>。成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;换了新的电脑，想把在 hexo 上的部署文件转移到新电脑上。因为提前在 github 为此做了一些工作，就是按照网上一些朋友的建议，在 github 上创建两个分支，一个分支 「master」 用于 hexo 部署，另一个分支「hexo」用于存储源文件。这样当需要在一台新电脑上使用 hexo 时，只需要把源文件 clone 到本地就行了。但事情总不是一帆风顺😅。今天遇到的问题是，把源文件拉到本地以后，每次执行 &lt;code&gt;hexo d&lt;/code&gt; 部署， 都会把所有源文件都部署到 &lt;code&gt;master&lt;/code&gt; 分支上。按照常理，应该是只有 public 文件夹里的内容才会放在 &lt;code&gt;master&lt;/code&gt; 分支下的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
